import { PrismaClient, Prisma } from '@prisma/client';
import { ChatService } from '@/lib/chat-service';
import { PROJECT_MAP, getPageRoutes, findRouteByPath } from '@/lib/ai/project-map';
import { renFeedbackService } from '@/lib/ai/ren-feedback-service';

const prisma = new PrismaClient();

/**
 * REN AI Service - Core intelligence for the RenThing AI personality
 *
 * This service provides:
 * 1. Natural language processing for user queries
 * 2. Context-aware responses based on user history and preferences
 * 3. Integration with existing platform features (listings, bookings, etc.)
 * 4. System monitoring capabilities for code quality and bug detection
 */

export interface AIContext {
  userId?: string;
  sessionId?: string;
  conversationHistory?: Array<{ role: string; content: string }>;
  currentLocation?: string;
  // Add geolocation data for enhanced location-based suggestions
  currentGeolocation?: {
    latitude: number;
    longitude: number;
  };
  userPreferences?: {
    language?: string;
    currency?: string;
    categories?: string[];
    priceRange?: { min: number; max: number };
    locations?: string[];
    // Add time-based preferences
    preferredBookingDays?: string[];
    preferredBookingHours?: number[];
  };
  userProfile?: {
    name?: string;
    joinDate?: Date;
    rentalHistory?: Array<{ listingId: string; rentedAt: Date; returnedAt?: Date }>;
    listedItems?: string[];
    favoriteCategories?: string[];
    preferredPriceRange?: { min: number; max: number };
    preferredLocations?: string[];
    calendarEvents?: CalendarEvent[]; // Add calendar events to user profile
  };
  currentSession?: {
    startTime: Date;
    currentPage?: string;
    actionsTaken?: string[];
  };
  // Add intent classification
  userIntent?: UserIntent;
  // Add conversation state
  conversationState?: ConversationState;
  // Add user preferences memory
  rememberedPreferences?: {
    [key: string]: any;
  };
  // Add sentiment analysis
  userSentiment?: UserSentiment;
  // Add inferred preferences from implicit feedback
  inferredPreferences?: {
    preferredCategories?: string[];
    preferredPriceRange?: { min: number; max: number; avg: number };
    preferredLocations?: string[];
    engagementLevel?: string;
    bookingPatterns?: {
      preferredDays?: string[];
      preferredHours?: number[];
      avgDuration?: number;
    };
    // Add time-based inferred preferences
    preferredBookingDays?: string[];
    preferredBookingHours?: number[];
  };
  // Add conversation topic tracking for better context retention
  conversationTopic?: {
    primaryTopic: string;
    secondaryTopics: string[];
    topicConfidence: number;
    lastMentioned: Date;
  };
  // Add entity memory for cross-turn entity retention
  rememberedEntities?: {
    items?: string[];
    locations?: string[];
    dates?: string[];
    prices?: number[];
    categories?: string[];
  };
  // Add user goal tracking
  userGoal?: {
    type: 'booking' | 'listing' | 'search' | 'account' | 'payment' | 'support' | 'other';
    details: any;
    progress: number; // 0-100
    createdAt: Date;
  };
}

// Add calendar event interface
export interface CalendarEvent {
  id: string;
  title: string;
  start: Date;
  end: Date;
  description?: string;
  location?: string;
  category?: string;
}

// Add sentiment analysis interface
export interface UserSentiment {
  tone: 'positive' | 'negative' | 'neutral' | 'frustrated' | 'excited';
  confidence: number;
  indicators: string[]; // Words or phrases that indicate sentiment
}

// Add intent classification interface
export interface UserIntent {
  type: 'booking' | 'listing' | 'search' | 'account' | 'payment' | 'support' | 'other';
  confidence: number;
  entities?: {
    items?: string[];
    dates?: string[];
    locations?: string[];
    prices?: number[];
  };
}

export interface ConversationState {
  workflow?: string; // Current workflow (e.g., 'booking', 'listing', 'search')
  step?: number; // Current step in workflow
  data?: { [key: string]: any }; // Data collected during workflow
  lastIntent?: UserIntent; // Last identified intent
  clarificationNeeded?: boolean; // Whether clarification is needed
  // Add wizard state
  wizard?: WizardState;
  // Add conversation flow tracking
  previousTopics?: string[];
  contextShifts?: number;
  lastEntityMention?: {
    type: string;
    value: string;
    timestamp: Date;
  };
}

// Add wizard state interface
export interface WizardState {
  type: 'listing' | 'booking' | 'search' | 'account';
  step: number;
  totalSteps: number;
  data: { [key: string]: any };
  progress: number; // 0-100
}

export class RenAIService {
  private chatService: ChatService;
  // Add conversation memory storage
  private conversationMemory: Map<string, AIContext> = new Map();
  
  // Define wizards
  private wizards = {
    listing: {
      steps: [
        { 
          prompt: "What item would you like to list for rent?", 
          expectedData: "itemName",
          examples: ["Camera", "Power tools", "Party decorations", "Sports equipment"]
        },
        { 
          prompt: "What is the daily rental price for your item?", 
          expectedData: "price",
          examples: ["₱500", "₱1,200", "₱50"]
        },
        { 
          prompt: "Please describe your item in detail. Include condition, features, and any accessories.", 
          expectedData: "description",
          examples: ["Brand new DSLR camera with 24-70mm lens", "Well-maintained power drill set with 50 pieces"]
        },
        { 
          prompt: "Where is your item located? This helps renters find it.", 
          expectedData: "location",
          examples: ["Makati City", "Quezon City", "Cebu City"]
        },
        { 
          prompt: "Would you like to add photos of your item? You can upload them after creating the listing.", 
          expectedData: "photos",
          options: ["Yes, I'll add photos", "No photos needed"]
        }
      ],
      totalSteps: 5
    },
    booking: {
      steps: [
        { 
          prompt: "What item would you like to rent?", 
          expectedData: "itemName",
          examples: ["Camera", "Power tools", "Party decorations", "Sports equipment"]
        },
        { 
          prompt: "When would you like to rent this item?", 
          expectedData: "dates",
          examples: ["Next week", "This weekend", "Tomorrow to Thursday"]
        },
        { 
          prompt: "How long do you need the item for?", 
          expectedData: "duration",
          examples: ["1 day", "3 days", "1 week", "2 weeks"]
        },
        { 
          prompt: "Do you have any special requests or questions for the owner?", 
          expectedData: "requests",
          examples: ["Need delivery", "Want to know if it comes with accessories", "Flexible on pickup time"]
        }
      ],
      totalSteps: 4
    }
  };

  constructor() {
    this.chatService = new ChatService();
  }

  /**
   * Get conversation context with memory
   * @param sessionId The session ID
   * @returns The conversation context with memory
   */
  private getConversationContext(sessionId: string): AIContext | undefined {
    return this.conversationMemory.get(sessionId);
  }

  /**
   * Update conversation context with memory
   * @param sessionId The session ID
   * @param context The updated context
   */
  private updateConversationContext(sessionId: string, context: AIContext): void {
    // Enhance context with conversation memory
    const enhancedContext = this.enhanceContextWithMemory(context);
    this.conversationMemory.set(sessionId, enhancedContext);
  }

  /**
   * Enhance context with conversation memory for better retention
   * @param context The current context
   * @returns Enhanced context with memory
   */
  private enhanceContextWithMemory(context: AIContext): AIContext {
    // Initialize remembered preferences if not present
    if (!context.rememberedPreferences) {
      context.rememberedPreferences = {};
    }
    
    // Initialize remembered entities if not present
    if (!context.rememberedEntities) {
      context.rememberedEntities = {};
    }
    
    // Remember user preferences across conversations
    if (context.userPreferences) {
      context.rememberedPreferences = {
        ...context.rememberedPreferences,
        ...context.userPreferences
      };
    }
    
    // Remember inferred preferences
    if (context.inferredPreferences) {
      context.rememberedPreferences = {
        ...context.rememberedPreferences,
        inferred: context.inferredPreferences
      };
    }
    
    // Remember entities across conversation turns
    if (context.userIntent?.entities) {
      const entities = context.userIntent.entities;
      
      // Merge with remembered entities
      context.rememberedEntities = {
        items: [
          ...(context.rememberedEntities.items || []),
          ...(entities.items || [])
        ].slice(-5), // Keep last 5 items
        locations: [
          ...(context.rememberedEntities.locations || []),
          ...(entities.locations || [])
        ].slice(-3), // Keep last 3 locations
        dates: [
          ...(context.rememberedEntities.dates || []),
          ...(entities.dates || [])
        ].slice(-3), // Keep last 3 dates
        prices: [
          ...(context.rememberedEntities.prices || []),
          ...(entities.prices || [])
        ].slice(-3), // Keep last 3 prices
        categories: [
          ...(context.rememberedEntities.categories || []),
          ...(context.userPreferences?.categories || [])
        ].slice(-5) // Keep last 5 categories
      };
    }
    
    // Track conversation topic
    if (context.userIntent) {
      const topic = this.determineConversationTopic(context.userIntent);
      if (topic) {
        context.conversationTopic = {
          primaryTopic: topic.primary,
          secondaryTopics: topic.secondary,
          topicConfidence: topic.confidence,
          lastMentioned: new Date()
        };
      }
    }
    
    // Track user goals
    if (context.userIntent && context.userIntent.type !== 'other') {
      // Update or create user goal
      if (!context.userGoal || context.userGoal.type !== context.userIntent.type) {
        context.userGoal = {
          type: context.userIntent.type,
          details: context.userIntent.entities || {},
          progress: 0,
          createdAt: new Date()
        };
      } else {
        // Update existing goal with new information
        context.userGoal.details = {
          ...context.userGoal.details,
          ...context.userIntent.entities
        };
        // Increase progress based on new information
        context.userGoal.progress = Math.min(context.userGoal.progress + 10, 100);
      }
    }
    
    return context;
  }

  /**
   * Determine conversation topic based on user intent
   * @param intent The user intent
   * @returns Topic information
   */
  private determineConversationTopic(intent: UserIntent): { primary: string; secondary: string[]; confidence: number } | null {
    const topics: string[] = [];
    
    // Determine primary topic based on intent type
    let primaryTopic = '';
    switch (intent.type) {
      case 'booking':
        primaryTopic = 'rental_booking';
        topics.push('availability', 'dates', 'pricing');
        break;
      case 'listing':
        primaryTopic = 'item_listing';
        topics.push('pricing', 'description', 'photos');
        break;
      case 'search':
        primaryTopic = 'item_search';
        topics.push('categories', 'locations', 'prices');
        break;
      case 'account':
        primaryTopic = 'account_management';
        topics.push('profile', 'settings', 'preferences');
        break;
      case 'payment':
        primaryTopic = 'payment_processing';
        topics.push('billing', 'transactions', 'refunds');
        break;
      case 'support':
        primaryTopic = 'customer_support';
        topics.push('issues', 'help', 'troubleshooting');
        break;
      case 'wishlist':
        primaryTopic = 'wishlist_management';
        topics.push('favorites', 'saved_items', 'notifications');
        break;
      case 'review':
        primaryTopic = 'review_management';
        topics.push('ratings', 'feedback', 'past_rentals');
        break;
      default:
        primaryTopic = 'general';
    }
    
    // Add topics based on entities
    if (intent.entities?.items?.length) {
      topics.push('items', ...intent.entities.items);
    }
    
    if (intent.entities?.locations?.length) {
      topics.push('locations', ...intent.entities.locations);
    }
    
    if (intent.entities?.dates?.length) {
      topics.push('dates', 'scheduling');
    }
    
    if (intent.entities?.prices?.length) {
      topics.push('pricing', 'budget');
    }
    
    // Remove duplicates and limit to 5 secondary topics
    const secondaryTopics = [...new Set(topics)].filter(topic => topic !== primaryTopic).slice(0, 5);
    
    return {
      primary: primaryTopic,
      secondary: secondaryTopics,
      confidence: intent.confidence
    };
  }

  /**
   * Get conversation context with enhanced memory
   * @param sessionId The session ID
   * @returns The enhanced conversation context
   */
  private getEnhancedConversationContext(sessionId: string): AIContext | undefined {
    const context = this.getConversationContext(sessionId);
    if (!context) return undefined;
    
    // Enhance context with remembered information
    const enhancedContext: AIContext = { ...context };
    
    // Apply remembered preferences
    if (context.rememberedPreferences) {
      enhancedContext.userPreferences = {
        ...enhancedContext.userPreferences,
        ...context.rememberedPreferences
      };
      
      // Apply inferred preferences if available
      if (context.rememberedPreferences.inferred) {
        enhancedContext.inferredPreferences = {
          ...enhancedContext.inferredPreferences,
          ...context.rememberedPreferences.inferred
        };
      }
    }
    
    // Apply remembered entities
    if (context.rememberedEntities) {
      enhancedContext.rememberedEntities = context.rememberedEntities;
    }
    
    // Apply conversation topic
    if (context.conversationTopic) {
      enhancedContext.conversationTopic = context.conversationTopic;
    }
    
    // Apply user goal
    if (context.userGoal) {
      enhancedContext.userGoal = context.userGoal;
    }
    
    return enhancedContext;
  }

  /**
   * Analyze user sentiment from their message
   * @param message The user's input message
   * @returns Analyzed sentiment with confidence score
   */
  private analyzeSentiment(message: string): UserSentiment {
    const lowerMessage = message.toLowerCase();
    
    // Define sentiment indicators
    const positiveIndicators = [
      'great', 'awesome', 'excellent', 'wonderful', 'fantastic', 'amazing', 'love', 'like',
      'perfect', 'good', 'nice', 'thank', 'thanks', 'happy', 'pleased', 'satisfied', 'cool'
    ];
    
    const negativeIndicators = [
      'bad', 'terrible', 'awful', 'horrible', 'hate', 'dislike', 'worst', 'angry',
      'frustrated', 'annoyed', 'upset', 'disappointed', 'confused', 'difficult'
    ];
    
    const frustratedIndicators = [
      'frustrated', 'annoyed', 'upset', 'angry', 'why can\'t', 'doesn\'t work', 'not working',
      'broken', 'stupid', 'useless', 'waste', 'problem', 'issue', 'error', 'failed'
    ];
    
    const excitedIndicators = [
      'excited', 'thrilled', 'eager', 'can\'t wait', 'looking forward', 'exciting'
    ];
    
    // Count matches for each sentiment
    const positiveMatches = positiveIndicators.filter(indicator => lowerMessage.includes(indicator));
    const negativeMatches = negativeIndicators.filter(indicator => lowerMessage.includes(indicator));
    const frustratedMatches = frustratedIndicators.filter(indicator => lowerMessage.includes(indicator));
    const excitedMatches = excitedIndicators.filter(indicator => lowerMessage.includes(indicator));
    
    // Determine sentiment based on matches
    const indicators: string[] = [];
    let tone: UserSentiment['tone'] = 'neutral';
    let confidence = 0.5;
    
    if (frustratedMatches.length > 0) {
      tone = 'frustrated';
      confidence = Math.min(0.5 + (frustratedMatches.length * 0.2), 1.0);
      indicators.push(...frustratedMatches);
    } else if (excitedMatches.length > 0) {
      tone = 'excited';
      confidence = Math.min(0.5 + (excitedMatches.length * 0.2), 1.0);
      indicators.push(...excitedMatches);
    } else if (positiveMatches.length > negativeMatches.length) {
      tone = 'positive';
      confidence = Math.min(0.5 + ((positiveMatches.length - negativeMatches.length) * 0.1), 1.0);
      indicators.push(...positiveMatches);
    } else if (negativeMatches.length > positiveMatches.length) {
      tone = 'negative';
      confidence = Math.min(0.5 + ((negativeMatches.length - positiveMatches.length) * 0.1), 1.0);
      indicators.push(...negativeMatches);
    } else if (positiveMatches.length > 0) {
      tone = 'positive';
      confidence = 0.6;
      indicators.push(...positiveMatches);
    } else if (negativeMatches.length > 0) {
      tone = 'negative';
      confidence = 0.6;
      indicators.push(...negativeMatches);
    }
    
    return {
      tone,
      confidence,
      indicators: [...new Set(indicators)] // Remove duplicates
    };
  }

  /**
   * Classify user intent from their message with enhanced sophistication
   * @param message The user's input message
   * @returns Classified intent with confidence score
   */
  private classifyIntent(message: string): UserIntent {
    const lowerMessage = message.toLowerCase();
    
    // Add greeting detection
    const greetingPatterns = [
      'hello', 'hi', 'hey', 'good morning', 'good afternoon', 'good evening',
      'greetings', 'howdy', 'what\'s up', 'how are you'
    ];
    
    const isGreeting = greetingPatterns.some(pattern => lowerMessage.includes(pattern));
    
    if (isGreeting) {
      return {
        type: 'greeting',
        confidence: 0.9,
        entities: undefined
      };
    }
    
    // Enhanced intent patterns with more sophisticated matching
    const bookingPatterns = [
      'book', 'rent', 'reserve', 'availability', 'dates', 'calendar',
      'when can i', 'can i rent', 'i want to rent', 'i need to rent',
      'rental period', 'pickup', 'drop off', 'delivery', 'return',
      'schedule', 'time slot', 'booking confirmation', 'reservation'
    ];
    
    const listingPatterns = [
      'list', 'sell', 'offer', 'rent out', 'put up', 'post',
      'how to list', 'create listing', 'add item', 'my items',
      'rent my', 'share my', 'make available', 'publish',
      'item details', 'rental price', 'daily rate', 'pricing',
      'availability calendar', 'rental terms', 'description',
      'photos', 'images', 'condition', 'accessories'
    ];
    
    const searchPatterns = [
      'find', 'search', 'look for', 'want', 'need', 'show me',
      'looking for', 'where can i', 'any', 'have', 'available',
      'browse', 'explore', 'see', 'check', 'view', 'display',
      'filter', 'sort', 'category', 'type', 'kind', 'range',
      'budget', 'price range', 'under', 'less than', 'affordable'
    ];
    
    const accountPatterns = [
      'profile', 'account', 'settings', 'update', 'change',
      'my info', 'personal', 'preferences', 'password',
      'username', 'email', 'phone', 'address', 'location',
      'notification', 'privacy', 'security', 'delete account',
      'close account', 'deactivate', 'login', 'logout', 'sign in',
      'sign up', 'register', 'forgot password', 'reset password'
    ];
    
    const paymentPatterns = [
      'pay', 'payment', 'price', 'cost', 'fee', 'charge',
      'how much', 'bill', 'invoice', 'refund', 'transaction',
      'credit card', 'debit card', 'gcash', 'paypal', 'bank transfer',
      'payment method', 'billing', 'checkout', 'complete payment',
      'payment status', 'failed payment', 'payment confirmation'
    ];
    
    const supportPatterns = [
      'help', 'support', 'problem', 'issue', 'broken', 'not working',
      'contact', 'assistance', 'question', 'how to', 'trouble',
      'error', 'bug', 'glitch', 'malfunction', 'complaint',
      'feedback', 'suggestion', 'report', 'compliment', 'praise'
    ];
    
    const wishlistPatterns = [
      'wishlist', 'favorite', 'save for later', 'bookmark',
      'add to wishlist', 'remove from wishlist', 'my wishlist',
      'saved items', 'interested in', 'want to rent later'
    ];
    
    const reviewPatterns = [
      'review', 'rating', 'rate', 'feedback', 'comment',
      'leave review', 'submit rating', 'my reviews',
      'previous rentals', 'past bookings', 'experience'
    ];
    
    // Count matches for each intent with weighted scoring
    const intentScores = {
      booking: this.calculatePatternScore(lowerMessage, bookingPatterns),
      listing: this.calculatePatternScore(lowerMessage, listingPatterns),
      search: this.calculatePatternScore(lowerMessage, searchPatterns),
      account: this.calculatePatternScore(lowerMessage, accountPatterns),
      payment: this.calculatePatternScore(lowerMessage, paymentPatterns),
      support: this.calculatePatternScore(lowerMessage, supportPatterns),
      wishlist: this.calculatePatternScore(lowerMessage, wishlistPatterns),
      review: this.calculatePatternScore(lowerMessage, reviewPatterns)
    };
    
    // Find the intent with the highest score
    const intentEntries = Object.entries(intentScores);
    const [topIntent, score] = intentEntries.reduce((max, entry) => entry[1] > max[1] ? entry : max, ['', 0]);
    
    // Extract entities
    const entities = this.extractEntities(message);
    
    // If no clear intent, classify as 'other'
    const intentType = score > 0 ? topIntent as UserIntent['type'] : 'other';
    const confidence = score > 0 ? Math.min(score / 5, 1) : 0.3;
    
    return {
      type: intentType,
      confidence,
      entities
    };
  }

  /**
   * Calculate pattern matching score with sophisticated weighting
   * @param message The user's input message
   * @param patterns Array of patterns to match
   * @returns Weighted score
   */
  private calculatePatternScore(message: string, patterns: string[]): number {
    let score = 0;
    
    // Exact matches get higher weight
    patterns.forEach(pattern => {
      if (message.includes(pattern)) {
        // Longer patterns are more specific and get higher weight
        score += pattern.split(' ').length;
      }
    });
    
    return score;
  }

  /**
   * Extract entities from user message with enhanced sophistication
   * @param message The user's input message
   * @returns Extracted entities
   */
  private extractEntities(message: string): UserIntent['entities'] {
    const entities: UserIntent['entities'] = {};
    
    // Extract potential items with enhanced pattern matching
    const itemPattern = /\b(camera|lens|tripod|drone|tool|equipment|bike|car|vehicle|dress|clothes|party|decoration|speaker|sound|light|projector|tent|camping|sports|game|toy|furniture|chair|table|monitor|computer|laptop|phone|tablet|book|instrument|music|art|paint|brush|vacuum|cleaner|kitchen|cook|bake|garden|plant|pet|baby|child|kid|sports|fitness|health|medical|office|work|study|school|education|wedding|event|celebration|holiday|christmas|valentine|halloween|new year|backpack|bag|purse|jewelry|watch|shoes|boots|sandals|hat|cap|sunglasses|gloves|scarf|coat|jacket|shirt|pants|jeans|shorts|skirt|dress|suit|tie|belt|socks|underwear|swimsuit|costume|uniform|accessories|appliances|electronics|gadgets|devices|machines|utensils|cookware|bakeware|linens|bedding|towels|blankets|pillows|cushions|curtains|blinds|rugs|carpets|mirrors|frames|clocks|vases|ornaments|collectibles|antiques|vintage|handmade|crafts|diy|materials|supplies|tools|hardware|fixtures|plumbing|electrical|painting|decor|ornament|statue|figure|doll|action figure|board game|card game|puzzle|toy|sports equipment|fitness equipment|exercise|workout|yoga|pilates|dance|music|karaoke|dj|recording|studio|lighting|photography|video|film|movie|tv|television|streaming|gaming|console|vr|ar|augmented reality|virtual reality|smart home|automation|security|safety|first aid|medical|health|beauty|cosmetics|skincare|haircare|nail|makeup|fragrance|perfume|cleaning|laundry|storage|organization|moving|packing|travel|luggage|backpack|camping|outdoor|garden|lawn|yard|patio|deck|porch|balcony|terrace|roof|garage|shed|workshop|basement|attic|crawl space|closet|wardrobe|pantry|cellar|wine|bar|kitchen|dining|living|family|bed|bath|powder|guest|study|office|den|library|playroom|game|media|theater|home|theater|entertainment|utility|laundry|mechanic|tool|shed|greenhouse|playhouse|gazebo|pergola|fountain|pond|water|feature|fire|pit|bbq|grill|outdoor|kitchen|patio|furniture|umbrella|awning|canopy|tent|awning|carport|garage|door|window|shutter|blind|curtain|drape|valance|swag|cornice|rod|pole|track|hardware|handle|knob|lock|latch|hinge|catch|strike|plate|escutcheon|strike|plate|threshold|sill|frame|jamb|header|sash|glazing|weatherstripping|seal|caulk|insulation|weatherization|ventilation|fan|heater|air|conditioner|heat|pump|boiler|furnace|radiator|baseboard|space|heater|fireplace|stove|oven|range|cooktop|microwave|refrigerator|freezer|dishwasher|washer|dryer|garbage|disposal|water|heater|softener|filter|purifier|humidifier|dehumidifier|generator|solar|panel|battery|inverter|charger|transformer|converter|adapter|plug|outlet|switch|dimmer|timer|sensor|detector|alarm|intercom|doorbell|camera|monitor|recorder|nvr|dvr|router|modem|network|wireless|wifi|bluetooth|ethernet|cable|wire|cord|extension|surge|protector|power|strip|battery|charger|inverter|solar|panel|generator|light|lamp|fixture|bulb|led|fluorescent|incandescent|halogen|cfl|smart|bulb|motion|sensor|daylight|sensor|timer|dimmer|switch|outdoor|lighting|landscape|lighting|path|light|step|light|wall|light|ceiling|light|pendant|light|chandelier|sconce|track|lighting|under|cabinet|lighting|night|light|emergency|light|exit|sign|security|light|flood|light|spotlight|work|light|task|light|reading|light|desk|lamp|table|lamp|floor|lamp|torchiere|arc|lamp|accent|light|decorative|light|novelty|light|holiday|light|christmas|light|halloween|light|valentine|light|easter|light|thanksgiving|light|independence|day|light|new|year|light|birthday|light|anniversary|light|wedding|light|graduation|light|baby|shower|light|bridal|shower|light|engagement|party|light|engagement|ring|light|diamond|light|gemstone|light|crystal|light|glass|light|metal|light|wood|light|plastic|light|fabric|light|paper|light|cardboard|light|foam|light|rubber|light|silicone|light|vinyl|light|pvc|light|abs|light|pc|light|pp|light|pe|light|ps|light|pet|light|plant|light|aquarium|light|terrarium|light|vivarium|light|reptile|light|amphibian|light|insect|light|arachnid|light|crustacean|light|mollusk|light|fish|light|bird|light|mammal|light|reptile|light|amphibian|light|insect|light|arachnid|light|crustacean|light|mollusk|light|fish|light|bird|light|mammal)\b/gi;
    const items = message.match(itemPattern);
    if (items) {
      entities.items = [...new Set(items.map(item => item.toLowerCase()))];
    }
    
    // Extract potential dates with enhanced pattern matching
    const datePattern = /\b(today|tomorrow|yesterday|next week|this week|next month|this month|\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}|\d{1,2}[\/\-]\d{1,2}|\d{1,2}(st|nd|rd|th)|january|february|march|april|may|june|july|august|september|october|november|december|monday|tuesday|wednesday|thursday|friday|saturday|sunday|weekend|weekday)\b/gi;
    const dates = message.match(datePattern);
    if (dates) {
      entities.dates = [...new Set(dates.map(date => date.toLowerCase()))];
    }
    
    // Extract potential locations (Philippine cities/regions) with enhanced pattern matching
    const locationPattern = /\b(manila|makati|quezon|taguig|pasay|mandaluyong|san juan|caloocan|pasig|marikina|parañaque|las piñas|cebu|davao|iloilo|bacolod|cagayan|bohol|pangasinan|laguna|rizal|bulacan|pampanga|tarlac|bataan|zambales|batangas|cavite|mindoro|palawan|aklan|samar|leyte|tacloban|cagayan|isabela|nueva|bataan|zambales|mindoro|aklan|samar|leyte|tacloban|cagayan|isabela|nueva|ecija|bataan|pampanga|tarlac|zambales|batangas|cavite|oriental mindoro|occidental mindoro|norte|sur|davao|del|norte|davao|del|sur|davao|occidental|davao|oriental|compostela|valley|south|cotabato|sarangani|general|santos|sultan|kudarat|north|cotabato|south|cotabato|agusan|del|norte|agusan|del|sur|surigao|del|norte|surigao|del|sur|dinagat|islands|biliran|eastern|samar|northern|samar|southern|leyte|quezon|polillo|islands|romblon|marinduque|masbate|sorsogon|albay|camarines|norte|camarines|sur|catanduanes|quezon|bataan|bulacan|nueva|ecija|pampanga|tarlac|zambales|batangas|cavite|laguna|quezon|rizal|metro|manila|calabarzon|region|iv-a|mimaropa|region|iv-b|bicol|region|v|cordillera|car|region|ii|region|iii|region|vii|region|viii|region|ix|region|x|region|xi|region|xii|region|xiii|armm|ncr|caraga|davao|region|region|iv-a|region|iv-b)\b/gi;
    const locations = message.match(locationPattern);
    if (locations) {
      entities.locations = [...new Set(locations.map(location => location.toLowerCase()))];
    }
    
    // Extract potential prices with enhanced pattern matching
    const pricePattern = /(?:₱|\bphp\b|\$)?\s*(\d+(?:\.\d{2})?)\b/gi;
    const prices = message.match(pricePattern);
    if (prices) {
      entities.prices = prices.map(price => {
        const cleanPrice = price.replace(/[₱$php]/gi, '').trim();
        return parseFloat(cleanPrice);
      }).filter(price => !isNaN(price));
    }
    
    // Extract potential durations
    const durationPattern = /\b(\d+\s*(day|days|week|weeks|month|months|hour|hours))\b/gi;
    const durations = message.match(durationPattern);
    if (durations) {
      entities.durations = [...new Set(durations.map(duration => duration.toLowerCase()))];
    }
    
    return Object.keys(entities).length > 0 ? entities : undefined;
  }

  /**
   * Handle ambiguous queries by asking clarifying questions with enhanced sophistication
   * @param message The user's input message
   * @param context The conversation context
   * @returns Clarification response if needed, otherwise null
   */
  private handleAmbiguousQuery(message: string, context: AIContext): AIResponse | null {
    const lowerMessage = message.toLowerCase();
    
    // Check if we need clarification based on intent confidence
    if (context.userIntent && context.userIntent.confidence < 0.5) {
      // Set clarification flag in conversation state
      if (!context.conversationState) {
        context.conversationState = {};
      }
      context.conversationState.clarificationNeeded = true;
      
      // Ask clarifying question based on potential entities
      if (context.userIntent.entities?.items?.length) {
        return {
          text: `I'm not sure exactly what you're looking for. Did you mean to search for ${context.userIntent.entities.items[0]} rentals?`,
          suggestions: [`Yes, search for ${context.userIntent.entities.items[0]}`, "No, let me rephrase", "Show me all categories"]
        };
      }
      
      if (context.userIntent.entities?.locations?.length) {
        return {
          text: `I noticed you mentioned ${context.userIntent.entities.locations[0]}. Are you looking for rentals in that area?`,
          suggestions: [`Yes, in ${context.userIntent.entities.locations[0]}`, "No, anywhere", "Show me nearby locations"]
        };
      }
      
      if (context.userIntent.entities?.dates?.length) {
        return {
          text: `I see you mentioned ${context.userIntent.entities.dates[0]}. Are you looking to rent something for that date?`,
          suggestions: [`Yes, find rentals for ${context.userIntent.entities.dates[0]}`, "No, let me rephrase", "Show me available dates"]
        };
      }
      
      if (context.userIntent.entities?.prices?.length) {
        const price = context.userIntent.entities.prices[0];
        return {
          text: `I noticed you mentioned ₱${price}. Are you looking for rentals within that price range?`,
          suggestions: [`Yes, show me rentals around ₱${price}`, "No, let me rephrase", "Show me all price ranges"]
        };
      }
      
      // Enhanced generic clarification with context-aware suggestions
      const suggestions = this.generateContextualClarificationSuggestions(context);
      
      return {
        text: "I'm not quite sure what you're asking for. Could you provide more details about what you need?",
        suggestions
      };
    }
    
    // Additional ambiguity detection based on message content
    if (this.isMessageAmbiguous(lowerMessage, context)) {
      // Set clarification flag in conversation state
      if (!context.conversationState) {
        context.conversationState = {};
      }
      context.conversationState.clarificationNeeded = true;
      
      // Generate context-aware clarification
      const clarification = this.generateAmbiguityClarification(lowerMessage, context);
      return clarification;
    }
    
    return null;
  }

  /**
   * Generate contextual clarification suggestions based on user context
   * @param context The conversation context
   * @returns Array of contextual suggestions
   */
  private generateContextualClarificationSuggestions(context: AIContext): string[] {
    const suggestions: string[] = [];
    
    // Add suggestions based on user history
    if (context.inferredPreferences?.preferredCategories?.length) {
      suggestions.push(`I'm looking for ${context.inferredPreferences.preferredCategories[0]} rentals`);
    }
    
    if (context.inferredPreferences?.preferredLocations?.length) {
      suggestions.push(`Find rentals in ${context.inferredPreferences.preferredLocations[0]}`);
    }
    
    // Add general suggestions
    suggestions.push("I want to rent something");
    suggestions.push("I want to list an item");
    suggestions.push("I need help with my account");
    suggestions.push("Never mind");
    
    // Limit to 4 suggestions
    return suggestions.slice(0, 4);
  }

  /**
   * Detect if a message is ambiguous based on content and context
   * @param message The user's input message
   * @param context The conversation context
   * @returns Whether the message is ambiguous
   */
  private isMessageAmbiguous(message: string, context: AIContext): boolean {
    // Check for vague terms that need clarification
    const vagueTerms = [
      'something', 'anything', 'stuff', 'things', 'item', 'it', 'this', 'that',
      'some', 'any', 'one', 'few', 'many', 'lot', 'several', 'various'
    ];
    
    // Check if message contains vague terms without specific entities
    const hasVagueTerms = vagueTerms.some(term => message.includes(term));
    const hasEntities = context.userIntent?.entities && 
      (context.userIntent.entities.items?.length || 
       context.userIntent.entities.locations?.length || 
       context.userIntent.entities.dates?.length || 
       context.userIntent.entities.prices?.length);
    
    // Message is ambiguous if it has vague terms but no specific entities
    if (hasVagueTerms && !hasEntities) {
      return true;
    }
    
    // Check for incomplete requests
    const incompletePatterns = [
      'i need', 'i want', 'looking for', 'find me', 'show me',
      'can you', 'could you', 'would you', 'help me'
    ];
    
    const isIncompleteRequest = incompletePatterns.some(pattern => 
      message.startsWith(pattern) && message.split(' ').length < 4
    );
    
    return isIncompleteRequest;
  }

  /**
   * Generate clarification for ambiguous messages
   * @param message The user's input message
   * @param context The conversation context
   * @returns Clarification response
   */
  private generateAmbiguityClarification(message: string, context: AIContext): AIResponse {
    // Check for common ambiguous patterns
    if (message.includes('something')) {
      return {
        text: "You mentioned 'something' - could you be more specific about what type of item you're looking for?",
        suggestions: [
          "I'm looking for tools",
          "I need party supplies",
          "I want sports equipment",
          "Show me popular categories"
        ]
      };
    }
    
    if (message.includes('anything')) {
      return {
        text: "You mentioned 'anything' - what category of items are you interested in?",
        suggestions: [
          "Show me all categories",
          "I'm looking for electronics",
          "I need home appliances",
          "I want outdoor equipment"
        ]
      };
    }
    
    // For incomplete requests
    if (message.startsWith('i need') || message.startsWith('i want')) {
      return {
        text: "Could you provide more details about what you need?",
        suggestions: [
          "I need it for a party",
          "I want something for outdoor use",
          "I need it this weekend",
          "I'm looking for affordable options"
        ]
      };
    }
    
    // Generic clarification
    return {
      text: "I'd like to help you better. Could you provide more specific details about what you're looking for?",
      suggestions: [
        "I'm looking for a specific item",
        "I need something for a specific date",
        "I want items in a specific location",
        "I have a specific budget in mind"
      ]
    };
  }

  /**
   * Adapt response tone based on user sentiment
   * @param response The AI response to adapt
   * @param sentiment The user's sentiment
   * @returns Adapted response
   */
  private adaptResponseToSentiment(response: AIResponse, sentiment: UserSentiment): AIResponse {
    // Create a copy of the response to modify
    const adaptedResponse = { ...response };
    
    // Adapt tone based on user sentiment
    switch (sentiment.tone) {
      case 'frustrated':
        // Add empathetic language
        adaptedResponse.text = `I understand this might be frustrating. ${adaptedResponse.text}`;
        // Add support suggestions
        if (adaptedResponse.suggestions) {
          adaptedResponse.suggestions = [...adaptedResponse.suggestions, "Contact support"];
        } else {
          adaptedResponse.suggestions = ["Contact support"];
        }
        break;
        
      case 'excited':
        // Add enthusiastic language
        adaptedResponse.text = `That's great to hear! ${adaptedResponse.text}`;
        break;
        
      case 'negative':
        // Add reassuring language
        adaptedResponse.text = `I'm sorry to hear that. ${adaptedResponse.text}`;
        break;
        
      case 'positive':
        // Add positive reinforcement
        adaptedResponse.text = `That's wonderful! ${adaptedResponse.text}`;
        break;
    }
    
    return adaptedResponse;
  }

  /**
   * Determine if we should escalate to human support
   * @param context The conversation context
   * @returns Whether to escalate and reason
   */
  private shouldEscalateToHuman(context: AIContext): { shouldEscalate: boolean; reason?: string } {
    // Escalate if user is frustrated and we've failed to help
    if (context.userSentiment?.tone === 'frustrated' && context.userSentiment.confidence > 0.7) {
      return {
        shouldEscalate: true,
        reason: "User appears frustrated with the service"
      };
    }
    
    // Escalate if user explicitly requests human support
    if (context.conversationHistory) {
      const lastUserMessage = context.conversationHistory.findLast(msg => msg.role === 'user');
      if (lastUserMessage) {
        const lowerMessage = lastUserMessage.content.toLowerCase();
        const humanSupportKeywords = [
          'human', 'person', 'agent', 'representative', 'customer service',
          'talk to a person', 'speak to someone', 'real person'
        ];
        
        const hasKeyword = humanSupportKeywords.some(keyword => lowerMessage.includes(keyword));
        if (hasKeyword) {
          return {
            shouldEscalate: true,
            reason: "User explicitly requested human support"
          };
        }
      }
    }
    
    // Escalate if we've been going in circles (multiple clarification attempts)
    if (context.conversationState?.clarificationNeeded) {
      // Count clarification attempts in conversation history
      let clarificationCount = 0;
      if (context.conversationHistory) {
        for (let i = context.conversationHistory.length - 1; i >= 0; i--) {
          const msg = context.conversationHistory[i];
          if (msg.role === 'assistant' && msg.content.includes('I\'m not quite sure')) {
            clarificationCount++;
          }
          // Only look at recent messages (last 5 turns)
          if (context.conversationHistory.length - i > 5) break;
        }
      }
      
      if (clarificationCount > 2) {
        return {
          shouldEscalate: true,
          reason: "Unable to understand user request after multiple attempts"
        };
      }
    }
    
    // Escalate for complex account issues
    if (context.userIntent?.type === 'account' && context.userIntent.confidence > 0.8) {
      // Check for complex account issues
      const lastUserMessage = context.conversationHistory?.findLast(msg => msg.role === 'user');
      if (lastUserMessage) {
        const lowerMessage = lastUserMessage.content.toLowerCase();
        const complexAccountIssues = [
          'deleted', 'suspended', 'banned', 'verification', 'id', 'document',
          'account locked', 'can\'t access', 'reset password', 'security'
        ];
        
        const hasComplexIssue = complexAccountIssues.some(issue => lowerMessage.includes(issue));
        if (hasComplexIssue) {
          return {
            shouldEscalate: true,
            reason: "Complex account issue requiring human intervention"
          };
        }
      }
    }
    
    return { shouldEscalate: false };
  }

  /**
   * Process a user message using the DeepSeek-R1 model
   * @param message The user's input message
   * @param context Context information about the user and conversation
   * @returns AI-generated response
   */
  async processMessage(message: string, context: AIContext): Promise<AIResponse> {
    // Get conversation context from memory if available
    if (context.sessionId) {
      const memoryContext = this.getConversationContext(context.sessionId);
      if (memoryContext) {
        // Merge memory context with current context, prioritizing current context
        context = { ...memoryContext, ...context };
      }
    }
    
    // Learn preferences from implicit feedback if user is logged in
    if (context.userId) {
      // Get combined user preferences (explicit + implicit)
      const userPreferences = await this.getUserPreferences(context.userId);
      if (userPreferences) {
        context.inferredPreferences = userPreferences;
      }
    }
    
    // Analyze user sentiment
    const sentiment = this.analyzeSentiment(message);
    context.userSentiment = sentiment;
    
    // Classify user intent
    const intent = this.classifyIntent(message);
    context.userIntent = intent;
    
    // Check if we're in a wizard flow
    if (context.conversationState?.wizard) {
      const wizardResponse = this.processWizardStep(message, context);
      if (wizardResponse) {
        // Save updated context to memory
        if (context.sessionId) {
          this.updateConversationContext(context.sessionId, context);
        }
        return wizardResponse;
      }
    }
    
    // Check if user wants to start a wizard
    const lowerMessage = message.toLowerCase();
    if (lowerMessage.includes('list an item') || lowerMessage.includes('create listing') || 
        (intent.type === 'listing' && intent.confidence > 0.7)) {
      const wizardResponse = this.startWizard('listing', context);
      // Save updated context to memory
      if (context.sessionId) {
        this.updateConversationContext(context.sessionId, context);
      }
      return wizardResponse;
    }
    
    if (lowerMessage.includes('book') || lowerMessage.includes('rent') || 
        (intent.type === 'booking' && intent.confidence > 0.7)) {
      const wizardResponse = this.startWizard('booking', context);
      // Save updated context to memory
      if (context.sessionId) {
        this.updateConversationContext(context.sessionId, context);
      }
      return wizardResponse;
    }
    
    // Check if we should escalate to human support
    const escalation = this.shouldEscalateToHuman(context);
    if (escalation.shouldEscalate) {
      const response: AIResponse = {
        text: `I understand you're having difficulty. Let me connect you with a human support agent who can better assist you with ${escalation.reason?.toLowerCase() || 'your request'}.`,
        suggestions: ["Connect to support", "Continue with AI assistant", "Go back"],
        action: { type: "escalate_to_human", payload: { reason: escalation.reason } }
      };
      
      // Log the interaction for self-improvement
      await this.logInteraction(message, response, context);
      
      // Save updated context to memory
      if (context.sessionId) {
        this.updateConversationContext(context.sessionId, context);
      }
      
      return response;
    }
    
    // Handle ambiguous queries
    const clarificationResponse = this.handleAmbiguousQuery(message, context);
    if (clarificationResponse) {
      // Adapt response to sentiment
      const adaptedResponse = this.adaptResponseToSentiment(clarificationResponse, sentiment);
      
      // Save updated context to memory
      if (context.sessionId) {
        this.updateConversationContext(context.sessionId, context);
      }
      return adaptedResponse;
    }
    
    // Update conversation state
    if (context.conversationState) {
      context.conversationState.lastIntent = intent;
      // Reset clarification flag
      context.conversationState.clarificationNeeded = false;
    }
    
    // Try to use DeepSeek-R1 model first (OpenRouter)
    try {
      const deepSeekResponse = await this.processWithOpenRouter(message, context);
      if (deepSeekResponse) {
        // Adapt response to sentiment
        const adaptedResponse = this.adaptResponseToSentiment(deepSeekResponse, sentiment);
        
        // Log the interaction for self-improvement
        await this.logInteraction(message, adaptedResponse, context);
        
        // Save updated context to memory
        if (context.sessionId) {
          this.updateConversationContext(context.sessionId, context);
        }
        
        return adaptedResponse;
      }
    } catch (error) {
      console.warn('DeepSeek model failed, falling back to rule-based system:', error);
    }

    // Fallback to rule-based system
    const ruleBasedResponse = await this.processMessageRuleBased(message, context);
    
    // Adapt response to sentiment
    const adaptedResponse = this.adaptResponseToSentiment(ruleBasedResponse, sentiment);
    
    // Log the interaction for self-improvement
    await this.logInteraction(message, adaptedResponse, context);
    
    // Save updated context to memory
    if (context.sessionId) {
      this.updateConversationContext(context.sessionId, context);
    }
    
    return adaptedResponse;
  }

  /**
   * Process a user message using rule-based responses (fallback)
   * @param message The user's input message
   * @param context Context information about the user and conversation
   * @returns AI-generated response
   */
  private async processMessageRuleBased(message: string, context: AIContext): Promise<AIResponse> {
    // Enhanced rule-based response system with better understanding of platform features

    const lowerMessage = message.toLowerCase();
    
    // Handle clarification responses
    if (context.conversationState?.clarificationNeeded) {
      // Reset clarification flag
      context.conversationState.clarificationNeeded = false;
      
      // Handle user responses to clarification
      if (lowerMessage.includes('yes') || lowerMessage.includes('yeah') || lowerMessage.includes('sure')) {
        // User confirmed, proceed with last intent
        if (context.conversationState.lastIntent) {
          context.userIntent = context.conversationState.lastIntent;
        }
      } else if (lowerMessage.includes('no') || lowerMessage.includes('nope') || lowerMessage.includes('never mind')) {
        return {
          text: "Okay, let's start over. How can I help you today?",
          suggestions: ["Find rentals", "List items", "Check bookings", "View wishlist"]
        };
      }
    }
    
    // Handle user intent
    if (context.userIntent) {
      switch (context.userIntent.type) {
        case 'greeting':
          return {
            text: "Hello! I'm REN, your rental marketplace assistant. I can help you find items to rent, list your own items, manage bookings, and more. How can I assist you today?",
            suggestions: ["Find rentals", "List items", "Check bookings", "View wishlist"]
          };
        case 'booking':
          // Personalize suggestions based on inferred preferences
          let bookingSuggestions = ["Camera", "Power tools", "Party decorations", "Sports equipment"];
          if (context.inferredPreferences?.preferredCategories?.length) {
            bookingSuggestions = [
              context.inferredPreferences.preferredCategories[0],
              context.inferredPreferences.preferredCategories[1] || "Power tools",
              "Party decorations",
              "Sports equipment"
            ];
          }
          return {
            text: "Sure, I can help you with that. What item would you like to rent?",
            suggestions: bookingSuggestions
          };
        case 'listing':
          // Personalize suggestions based on inferred preferences
          let listingSuggestions = ["Camera", "Power tools", "Party decorations", "Sports equipment"];
          if (context.inferredPreferences?.preferredCategories?.length) {
            listingSuggestions = [
              context.inferredPreferences.preferredCategories[0],
              context.inferredPreferences.preferredCategories[1] || "Power tools",
              "Party decorations",
              "Sports equipment"
            ];
          }
          return {
            text: "Great! What item would you like to list for rent?",
            suggestions: listingSuggestions
          };
        case 'search':
          // Personalize suggestions based on inferred preferences
          let searchSuggestions = ["Camera", "Power tools", "Party decorations", "Sports equipment"];
          if (context.inferredPreferences?.preferredCategories?.length) {
            searchSuggestions = [
              context.inferredPreferences.preferredCategories[0],
              context.inferredPreferences.preferredCategories[1] || "Power tools",
              "Party decorations",
              "Sports equipment"
            ];
          }
          return {
            text: "Sure, what are you looking for?",
            suggestions: searchSuggestions
          };
        case 'account':
          return {
            text: "Sure, what would you like to do with your account?",
            suggestions: ["Update profile", "Change password", "View rental history"]
          };
        case 'payment':
          return {
            text: "Sure, what payment-related information do you need?",
            suggestions: ["View balance", "Add payment method", "Check transaction history"]
          };
        case 'support':
          return {
            text: "Sure, how can I assist you?",
            suggestions: ["Report an issue", "Request a feature", "Contact support"]
          };
        case 'other':
          return {
            text: "I'm not sure what you're asking for. Could you provide more details?",
            suggestions: ["Find rentals", "List items", "Check bookings", "View wishlist"]
          };
      }
    }
    
    // Default response personalized with inferred preferences
    let defaultSuggestions = ["Find rentals", "List items", "Check bookings", "View wishlist"];
    if (context.inferredPreferences?.preferredCategories?.length) {
      defaultSuggestions = [
        `Find ${context.inferredPreferences.preferredCategories[0]} rentals`,
        "List items",
        "Check bookings",
        `View ${context.inferredPreferences.preferredCategories[1] || context.inferredPreferences.preferredCategories[0]} wishlist`
      ];
    }
    
    return {
      text: "Hello! How can I assist you today?",
      suggestions: defaultSuggestions
    };
  }

  /**
   * Log an interaction for self-improvement
   * @param userMessage The user's input message
   * @param response The AI-generated response
   * @param context Context information about the user and conversation
   */
  private async logInteraction(userMessage: string, response: AIResponse, context: AIContext): Promise<void> {
    // Log the interaction to a database or external service for analysis
    await prisma.interaction.create({
      data: {
        userId: context.userId,
        sessionId: context.sessionId,
        userMessage,
        responseText: response.text,
        responseSuggestions: response.suggestions,
        responseAction: response.action,
        conversationHistory: context.conversationHistory,
        userSentiment: context.userSentiment,
        userIntent: context.userIntent,
        conversationState: context.conversationState,
        rememberedPreferences: context.rememberedPreferences,
        createdAt: new Date()
      }
    });
  }

  /**
   * Process a wizard step
   * @param message The user's input message
   * @param context The conversation context
   * @returns AI-generated response
   */
  private processWizardStep(message: string, context: AIContext): AIResponse | null {
    if (!context.conversationState?.wizard) {
      return null;
    }
    
    const wizardState = context.conversationState.wizard;
    const wizard = this.wizards[wizardState.type];
    
    if (!wizard) {
      return null;
    }
    
    const currentStep = wizard.steps[wizardState.step];
    
    // Store the user's response for the current step
    wizardState.data[currentStep.expectedData] = message;
    
    // Move to the next step
    wizardState.step++;
    
    // Check if we've completed all steps
    if (wizardState.step >= wizard.steps.length) {
      // Wizard completed
      const summary = this.generateWizardSummary(wizardState);
      
      // Clear wizard state
      context.conversationState.wizard = undefined;
      
      return {
        text: `Great! You've completed the ${wizardState.type} process. Here's a summary of what we collected:\n\n${summary}\n\nWould you like to proceed with creating your listing or booking?`,
        suggestions: ["Yes, proceed", "Review my information", "Start over"],
        action: { 
          type: `wizard_complete_${wizardState.type}`, 
          payload: { data: wizardState.data } 
        }
      };
    }
    
    // Update progress
    wizardState.progress = Math.round((wizardState.step / wizardState.totalSteps) * 100);
    
    // Get next step
    const nextStep = wizard.steps[wizardState.step];
    
    return {
      text: `Step ${wizardState.step + 1} of ${wizardState.totalSteps}: ${nextStep.prompt}\n\nProgress: ${wizardState.progress}%`,
      suggestions: nextStep.examples || nextStep.options || ["Continue"]
    };
  }

  /**
   * Start a wizard
   * @param type The type of wizard to start
   * @param context The conversation context
   * @returns AI-generated response
   */
  private startWizard(type: 'listing' | 'booking', context: AIContext): AIResponse {
    const wizard = this.wizards[type];
    context.conversationState = {
      wizard: {
        type,
        step: 0,
        totalSteps: wizard.totalSteps,
        data: {},
        progress: 0
      }
    };
    
    const firstStep = wizard.steps[0];
    return {
      text: firstStep.prompt,
      suggestions: firstStep.options
    };
  }

  /**
   * Process a user message using the DeepSeek-R1 model (OpenRouter)
   * @param message The user's input message
   * @param context Context information about the user and conversation
   * @returns AI-generated response
   */
  private async processWithOpenRouter(message: string, context: AIContext): Promise<AIResponse | null> {
    // Use OpenRouter to process the message and generate a response
    const response = await this.chatService.sendMessage(message, context);
    return response;
  }

  /**
   * Get personalized recommendations for a user
   * @param userId The user ID to get recommendations for
   * @returns Array of recommended listings
   */

  /**
   * Get personalized recommendations for a user
   * @param userId The user ID to get recommendations for
   * @returns Array of recommended listings
   */
  async getRecommendations(userId: string) {
    // First try collaborative filtering
    const collaborativeRecs = await this.getCollaborativeRecommendations(userId);
    if (collaborativeRecs.length > 0) {
      return collaborativeRecs;
    }
    
    // Fallback to personalized recommendations
    return await this.getPersonalizedRecommendations(userId);
  }

  /**
   * Get live database information about a specific listing
   * @param listingId The ID of the listing to get information for
   * @returns Listing information
   */
  async getListingInfo(listingId: string) {
    try {
      const listing = await prisma.listing.findUnique({
        where: { id: listingId },
        include: {
          owner: {
            select: {
              id: true,
              name: true,
              email: true
            }
          },
          reviews: {
            select: {
              id: true,
              rating: true,
              comment: true,
              user: {
                select: {
                  id: true,
                  name: true
                }
              },
              createdAt: true
            }
          }
        }
      });

      if (!listing) {
        return null;
      }

      // Calculate average rating
      const totalRating = listing.reviews.reduce((sum, review) => sum + review.rating, 0);
      const averageRating = listing.reviews.length > 0 ? totalRating / listing.reviews.length : 0;

      return {
        id: listing.id,
        title: listing.title,
        description: listing.description,
        price: listing.price,
        location: listing.location,
        images: JSON.parse(listing.images || '[]'),
        features: JSON.parse(listing.features || '[]'),
        ownerId: listing.ownerId,
        owner: listing.owner,
        averageRating: averageRating,
        reviewCount: listing.reviews.length,
        reviews: listing.reviews,
        createdAt: listing.createdAt
      };
    } catch (error) {
      console.error('Error getting listing info:', error);
      return null;
    }
  }

  /**
   * Get live trending listings for recommendations
   * @returns Array of trending listings
   */
  async getTrendingListings() {
    try {
      const listings = await prisma.listing.findMany({
        take: 10,
        orderBy: {
          createdAt: 'desc'
        },
        include: {
          owner: {
            select: {
              id: true,
              name: true
            }
          },
          reviews: {
            select: {
              rating: true
            }
          }
        }
      });

      // Calculate average ratings
      const enrichedListings = listings.map(listing => {
        const totalRating = listing.reviews.reduce((sum, review) => sum + review.rating, 0);
        const averageRating = listing.reviews.length > 0 ? totalRating / listing.reviews.length : 0;
        
        return {
          id: listing.id,
          title: listing.title,
          description: listing.description,
          price: listing.price,
          location: listing.location,
          images: JSON.parse(listing.images || '[]'),
          ownerId: listing.ownerId,
          ownerName: listing.owner.name,
          averageRating: averageRating,
          reviewCount: listing.reviews.length,
          createdAt: listing.createdAt
        };
      });

      return enrichedListings;
    } catch (error) {
      console.error('Error getting trending listings:', error);
      return [];
    }
  }

  /**
   * Search listings using natural language query
   * @param query Natural language search query
   * @param context Current user context
   * @returns Array of matching listings
   */
  async searchListingsWithNaturalLanguage(query: string, context: AIContext) {
    try {
      // Extract entities from the query
      const entities = this.extractEntities(query);
      
      // Build search criteria
      const searchCriteria: any = {};
      
      // Add item search criteria
      if (entities?.items?.length) {
        searchCriteria.OR = [
          { title: { contains: entities.items[0], mode: 'insensitive' } },
          { description: { contains: entities.items[0], mode: 'insensitive' } }
        ];
      }
      
      // Add location search criteria
      if (entities?.locations?.length) {
        searchCriteria.location = { contains: entities.locations[0], mode: 'insensitive' };
      }
      
      // Add price range criteria
      if (entities?.prices?.length) {
        // Use the first price as a reference point
        const referencePrice = entities.prices[0];
        searchCriteria.price = {
          gte: referencePrice * 0.7, // 30% below
          lte: referencePrice * 1.3  // 30% above
        };
      }
      
      // Add date criteria if needed (for availability)
      if (entities?.dates?.length) {
        // For now, we'll just log that date information was found
        console.log('Date entities found:', entities.dates);
      }
      
      // Perform the search
      const listings = await prisma.listing.findMany({
        where: searchCriteria,
        take: 10,
        include: {
          owner: {
            select: {
              id: true,
              name: true
            }
          },
          reviews: {
            select: {
              rating: true
            }
          }
        }
      });

      // Calculate average ratings
      const enrichedListings = listings.map(listing => {
        const totalRating = listing.reviews.reduce((sum, review) => sum + review.rating, 0);
        const averageRating = listing.reviews.length > 0 ? totalRating / listing.reviews.length : 0;
        
        return {
          id: listing.id,
          title: listing.title,
          description: listing.description,
          price: listing.price,
          location: listing.location,
          images: JSON.parse(listing.images || '[]'),
          ownerId: listing.ownerId,
          ownerName: listing.owner.name,
          averageRating: averageRating,
          reviewCount: listing.reviews.length,
          createdAt: listing.createdAt
        };
      });

      return enrichedListings;
    } catch (error) {
      console.error('Error searching listings with natural language:', error);
      return [];
    }
  }

  /**
   * Get user's recent activity for context
   * @param userId The user ID to get activity for
   * @returns User activity information
   */
  async getUserActivity(userId: string) {
    try {
      // Get recent bookings
      const recentBookings = await prisma.booking.findMany({
        where: {
          userId: userId,
          createdAt: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
          }
        },
        include: {
          listing: {
            select: {
              id: true,
              title: true,
              description: true,
              price: true,
              category: true
            }
          }
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 5
      });

      // Get wishlist items
      const wishlistItems = await prisma.wishlist.findMany({
        where: {
          userId: userId
        },
        include: {
          listing: {
            select: {
              id: true,
              title: true,
              description: true,
              price: true,
              category: true
            }
          }
        },
        take: 5
      });

      // Get unread messages
      const unreadMessages = await prisma.message.count({
        where: {
          receiverId: userId,
          read: false
        }
      });

      // Get user's reviews
      const recentReviews = await prisma.review.findMany({
        where: {
          userId: userId,
          createdAt: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
          }
        },
        include: {
          listing: {
            select: {
              id: true,
              title: true
            }
          }
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 5
      });

      // Get user's listed items
      const recentListings = await prisma.listing.findMany({
        where: {
          ownerId: userId,
          createdAt: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
          }
        },
        select: {
          id: true,
          title: true,
          description: true,
          price: true,
          category: true,
          createdAt: true
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 5
      });

      return {
        recentBookings,
        wishlistItems,
        unreadMessages,
        recentReviews,
        recentListings
      };
    } catch (error) {
      console.error('Error getting user activity:', error);
      return {
        recentBookings: [],
        wishlistItems: [],
        unreadMessages: 0,
        recentReviews: [],
        recentListings: []
      };
    }
  }

  /**
   * Get smart notifications for relevant listings based on user preferences
   * @param userId The user ID to get notifications for
   * @param context Current user context
   * @returns Array of smart notifications
   */
  async getSmartNotifications(userId: string, context: AIContext) {
    const notifications: Array<{type: string, message: string, listingId?: string, priority: number}> = [];
    
    try {
      // Get user's persona for personalization
      const persona = await this.generateUserPersona(userId);
      if (!persona) {
        return notifications;
      }
      
      // Get user's recent activity
      const userActivity = await this.getUserActivity(userId);
      
      // Price drop notifications for wishlist items
      for (const wishlistItem of userActivity.wishlistItems) {
        const listing = wishlistItem.listing;
        
        // Check if there are similar listings at lower prices
        const similarListings = await prisma.listing.findMany({
          where: {
            AND: [
              {
                description: {
                  contains: listing.description,
                  mode: 'insensitive'
                }
              },
              {
                price: {
                  lt: listing.price * 0.9 // 10% lower
                }
              },
              {
                id: {
                  not: listing.id
                }
              }
            ]
          },
          take: 1,
          orderBy: {
            price: 'asc'
          }
        });
        
        if (similarListings.length > 0) {
          const cheaperListing = similarListings[0];
          notifications.push({
            type: "price_drop",
            message: `Price drop alert! Similar item "${cheaperListing.title}" is available for ₱${cheaperListing.price} (₱${listing.price - cheaperListing.price} cheaper than your wishlist item)`,
            listingId: cheaperListing.id,
            priority: 8
          });
        }
      }
      
      // Availability alerts for popular items
      if (persona.favoriteCategories.length > 0) {
        const popularListings = await prisma.listing.findMany({
          where: {
            AND: [
              {
                category: {
                  in: persona.favoriteCategories
                }
              },
              {
                createdAt: {
                  gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days
                }
              }
            ]
          },
          take: 3,
          orderBy: {
            createdAt: 'desc'
          }
        });
        
        for (const listing of popularListings) {
          notifications.push({
            type: "new_popular_item",
            message: `New popular item in your favorite category: "${listing.title}" just listed!`,
            listingId: listing.id,
            priority: 6
          });
        }
      }
      
      // Seasonal listing suggestions for owners
      if (userActivity.recentListings.length > 0) {
        const currentMonth = new Date().getMonth();
        const seasonalSuggestions = {
          0: "New Year party supplies",
          1: "Valentine's Day gifts",
          2: "Gardening tools",
          3: "Umbrellas and rain gear",
          4: "Summer sports equipment",
          5: "Beach and swimming gear",
          6: "Summer party supplies",
          7: "Back-to-school supplies",
          8: "Outdoor cooking equipment",
          9: "Halloween decorations",
          10: "Holiday decorations",
          11: "Christmas gifts"
        };
        
        const suggestion = seasonalSuggestions[currentMonth];
        if (suggestion) {
          notifications.push({
            type: "seasonal_listing_suggestion",
            message: `Seasonal opportunity: Consider listing ${suggestion} to capitalize on upcoming demand`,
            priority: 5
          });
        }
      }
      
      // Sort notifications by priority
      return notifications.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error getting smart notifications:', error);
      return notifications;
    }
  }

  /**
   * Get predictive assistance based on user patterns
   * @param userId The user ID to get predictions for
   * @param context Current user context
   * @returns Array of predictive assistance suggestions
   */
  async getPredictiveAssistance(userId: string, context: AIContext) {
    const predictions: Array<{type: string, message: string, action?: string, priority: number}> = [];
    
    try {
      // Get user's persona for personalization
      const persona = await this.generateUserPersona(userId);
      if (!persona) {
        return predictions;
      }
      
      // Get user's recent activity
      const userActivity = await this.getUserActivity(userId);
      
      // Predictive assistance based on user type
      switch (persona.userType) {
        case 'power_user':
          predictions.push({
            type: "power_user_tip",
            message: "As a power user, you might want to try our advanced search filters to find exactly what you need faster.",
            action: "show_advanced_search",
            priority: 8
          });
          break;
        case 'active':
          predictions.push({
            type: "active_user_tip",
            message: "You're an active user! Consider upgrading to premium for exclusive benefits and lower fees.",
            action: "show_premium_benefits",
            priority: 7
          });
          break;
        case 'casual':
          predictions.push({
            type: "casual_user_tip",
            message: "New to renting? Check out our beginner's guide to get started!",
            action: "show_beginner_guide",
            priority: 6
          });
          break;
      }
      
      // Predictive assistance based on engagement level
      switch (persona.engagementLevel) {
        case 'high':
          predictions.push({
            type: "engagement_tip",
            message: "You're highly engaged with our platform! Refer a friend and earn rewards.",
            action: "show_referral_program",
            priority: 9
          });
          break;
        case 'medium':
          predictions.push({
            type: "engagement_tip",
            message: "You're getting familiar with our platform. Try listing an item you're not using to earn extra income.",
            action: "show_listing_guide",
            priority: 7
          });
          break;
        case 'low':
          predictions.push({
            type: "engagement_tip",
            message: "Welcome! Explore our trending items to discover what's popular right now.",
            action: "show_trending_items",
            priority: 5
          });
          break;
      }
      
      // Predictive assistance based on user tenure
      if (persona.tenureDays > 365) {
        predictions.push({
          type: "loyalty_tip",
          message: "Thank you for being a loyal user for over a year! Enjoy exclusive benefits as a long-term member.",
          action: "show_loyalty_benefits",
          priority: 10
        });
      } else if (persona.tenureDays > 180) {
        predictions.push({
          type: "milestone_tip",
          message: "You've been with us for 6 months! Keep going and unlock more features.",
          action: "show_user_progress",
          priority: 8
        });
      }
      
      // Predictive assistance based on recent activity
      if (userActivity.recentBookings.length > 0) {
        const lastBooking = userActivity.recentBookings[0];
        const daysSinceLastBooking = Math.floor((Date.now() - lastBooking.createdAt.getTime()) / (1000 * 60 * 60 * 24));
        
        if (daysSinceLastBooking > 30) {
          predictions.push({
            type: "return_user_tip",
            message: "It's been a while since your last rental. Check out new arrivals in categories you've rented before.",
            action: "show_new_arrivals",
            priority: 7
          });
        }
      }
      
      if (userActivity.recentListings.length > 0) {
        const lastListing = userActivity.recentListings[0];
        const daysSinceLastListing = Math.floor((Date.now() - lastListing.createdAt.getTime()) / (1000 * 60 * 60 * 24));
        
        if (daysSinceLastListing > 60) {
          predictions.push({
            type: "owner_tip",
            message: "Your listings could be earning more. Try updating your item descriptions with better photos.",
            action: "show_listing_optimization_tips",
            priority: 8
          });
        }
      }
      
      // Predictive assistance based on time of day
      const currentHour = new Date().getHours();
      if (currentHour >= 18 && currentHour <= 24) {
        predictions.push({
          type: "evening_tip",
          message: "Evening is a great time to list items for rent. People browse more in the evening!",
          action: "show_listing_form",
          priority: 6
        });
      } else if (currentHour >= 9 && currentHour <= 17) {
        predictions.push({
          type: "business_hours_tip",
          message: "Business hours are perfect for browsing rentals. Check out what's new!",
          action: "show_browse_page",
          priority: 6
        });
      }
      
      // Sort predictions by priority
      return predictions.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error getting predictive assistance:', error);
      return predictions;
    }
  }

  /**
   * Get automated booking assistance with alternatives
   * @param userId The user ID to get assistance for
   * @param context Current user context
   * @param originalListingId The ID of the original listing user wanted to book
   * @returns Array of booking assistance suggestions
   */
  async getBookingAssistance(userId: string, context: AIContext, originalListingId: string) {
    const assistance: Array<{type: string, message: string, listingId?: string, priority: number}> = [];
    
    try {
      // Get the original listing
      const originalListing = await prisma.listing.findUnique({
        where: { id: originalListingId },
        select: {
          id: true,
          title: true,
          description: true,
          price: true,
          category: true
        }
      });
      
      if (!originalListing) {
        return assistance;
      }
      
      // Find similar listings as alternatives
      const similarListings = await prisma.listing.findMany({
        where: {
          AND: [
            {
              category: originalListing.category
            },
            {
              id: {
                not: originalListing.id
              }
            }
          ]
        },
        take: 5,
        orderBy: {
          createdAt: 'desc'
        }
      });
      
      // Add alternatives
      for (const listing of similarListings) {
        assistance.push({
          type: "alternative_listing",
          message: `Alternative option: "${listing.title}" for ₱${listing.price}/day`,
          listingId: listing.id,
          priority: 8
        });
      }
      
      // Add price range alternatives
      const priceRangeListings = await prisma.listing.findMany({
        where: {
          AND: [
            {
              category: originalListing.category
            },
            {
              price: {
                gte: originalListing.price * 0.7,
                lte: originalListing.price * 1.3
              }
            },
            {
              id: {
                not: originalListing.id
              }
            }
          ]
        },
        take: 3,
        orderBy: {
          price: 'asc'
        }
      });
      
      // Add price alternatives
      for (const listing of priceRangeListings) {
        const priceDifference = listing.price - originalListing.price;
        const percentageDifference = Math.round((priceDifference / originalListing.price) * 100);
        
        if (priceDifference < 0) {
          assistance.push({
            type: "cheaper_alternative",
            message: `Cheaper option: "${listing.title}" for ₱${listing.price}/day (${Math.abs(percentageDifference)}% less)`,
            listingId: listing.id,
            priority: 9
          });
        } else {
          assistance.push({
            type: "premium_alternative",
            message: `Premium option: "${listing.title}" for ₱${listing.price}/day (${percentageDifference}% more)`,
            listingId: listing.id,
            priority: 7
          });
        }
      }
      
      // Add category alternatives
      const userPersona = await this.generateUserPersona(userId);
      if (userPersona && userPersona.favoriteCategories.length > 0) {
        const categoryAlternatives = await prisma.listing.findMany({
          where: {
            category: {
              in: userPersona.favoriteCategories
            }
          },
          take: 3,
          orderBy: {
            createdAt: 'desc'
          }
        });
        
        for (const listing of categoryAlternatives) {
          assistance.push({
            type: "favorite_category_alternative",
            message: `Based on your preferences: "${listing.title}" in your favorite category`,
            listingId: listing.id,
            priority: 6
          });
        }
      }
      
      // Sort assistance by priority
      return assistance.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error getting booking assistance:', error);
      return assistance;
    }
  }

  /**
   * Get availability alerts for popular items
   * @param userId The user ID to get alerts for
   * @returns Array of availability alerts
   */
  async getAvailabilityAlerts(userId: string) {
    const alerts: Array<{type: string, message: string, listingId: string, priority: number}> = [];
    
    try {
      // Get user's persona for personalization
      const persona = await this.generateUserPersona(userId);
      if (!persona) {
        return alerts;
      }
      
      // Get user's wishlist items
      const wishlistItems = await prisma.wishlist.findMany({
        where: {
          userId: userId
        },
        include: {
          listing: {
            select: {
              id: true,
              title: true,
              description: true
            }
          }
        }
      });
      
      // For each wishlist item, check if similar items become available
      for (const wishlistItem of wishlistItems) {
        const listing = wishlistItem.listing;
        
        // Look for recently listed similar items
        const similarListings = await prisma.listing.findMany({
          where: {
            AND: [
              {
                description: {
                  contains: listing.description,
                  mode: 'insensitive'
                }
              },
              {
                createdAt: {
                  gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
                }
              },
              {
                id: {
                  not: listing.id
                }
              }
            ]
          },
          take: 2,
          orderBy: {
            createdAt: 'desc'
          }
        });
        
        // Create alerts for newly available similar items
        for (const newItem of similarListings) {
          alerts.push({
            type: "availability_alert",
            message: `Newly available: Similar item "${newItem.title}" just listed!`,
            listingId: newItem.id,
            priority: 7
          });
        }
      }
      
      // Get trending items in user's favorite categories
      if (persona.favoriteCategories.length > 0) {
        const trendingListings = await prisma.listing.findMany({
          where: {
            AND: [
              {
                category: {
                  in: persona.favoriteCategories
                }
              },
              {
                createdAt: {
                  gte: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000) // Last 3 days
                }
              }
            ]
          },
          take: 3,
          orderBy: {
            createdAt: 'desc'
          }
        });
        
        // Create alerts for trending items
        for (const listing of trendingListings) {
          alerts.push({
            type: "trending_item",
            message: `Trending now: "${listing.title}" is getting popular!`,
            listingId: listing.id,
            priority: 6
          });
        }
      }
      
      // Sort alerts by priority
      return alerts.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error getting availability alerts:', error);
      return alerts;
    }
  }

  /**
   * Get price drop notifications for wishlist items
   * @param userId The user ID to get notifications for
   * @returns Array of price drop notifications
   */
  async getPriceDropNotifications(userId: string) {
    const notifications: Array<{type: string, message: string, listingId: string, priority: number, priceDifference: number}> = [];
    
    try {
      // Get user's wishlist items
      const wishlistItems = await prisma.wishlist.findMany({
        where: {
          userId: userId
        },
        include: {
          listing: {
            select: {
              id: true,
              title: true,
              price: true,
              description: true
            }
          }
        }
      });
      
      // Check each wishlist item for price drops
      for (const wishlistItem of wishlistItems) {
        const listing = wishlistItem.listing;
        
        // Look for similar items at lower prices
        const similarListings = await prisma.listing.findMany({
          where: {
            AND: [
              {
                description: {
                  contains: listing.description,
                  mode: 'insensitive'
                }
              },
              {
                price: {
                  lt: listing.price
                }
              },
              {
                id: {
                  not: listing.id
                }
              }
            ]
          },
          take: 3,
          orderBy: {
            price: 'asc'
          }
        });
        
        // Create notifications for each cheaper listing
        for (const cheaperListing of similarListings) {
          const priceDifference = listing.price - cheaperListing.price;
          const percentageDrop = Math.round((priceDifference / listing.price) * 100);
          
          notifications.push({
            type: "wishlist_price_drop",
            message: `Price drop! "${cheaperListing.title}" is now ₱${cheaperListing.price} (${percentageDrop}% cheaper than your wishlist item "${listing.title}")`,
            listingId: cheaperListing.id,
            priority: 9,
            priceDifference: priceDifference
          });
        }
      }
      
      // Sort notifications by priority
      return notifications.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error getting price drop notifications:', error);
      return notifications;
    }
  }

  /**
   * Get reminders for upcoming bookings or return dates
   * @param userId The user ID to get reminders for
   * @returns Array of booking reminders
   */
  async getBookingReminders(userId: string) {
    const reminders: Array<{type: string, message: string, bookingId: string, priority: number, timeUntilEvent: string}> = [];
    
    try {
      // Get upcoming bookings (within next 7 days)
      const upcomingBookings = await prisma.booking.findMany({
        where: {
          userId: userId,
          startDate: {
            gte: new Date(),
            lte: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // Next 7 days
          },
          status: 'confirmed'
        },
        include: {
          listing: {
            select: {
              title: true
            }
          }
        },
        orderBy: {
          startDate: 'asc'
        }
      });
      
      // Get bookings ending soon (within next 2 days)
      const endingBookings = await prisma.booking.findMany({
        where: {
          userId: userId,
          endDate: {
            gte: new Date(),
            lte: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000) // Next 2 days
          },
          status: 'confirmed'
        },
        include: {
          listing: {
            select: {
              title: true
            }
          }
        },
        orderBy: {
          endDate: 'asc'
        }
      });
      
      // Create pickup reminders
      for (const booking of upcomingBookings) {
        const timeUntilStart = Math.ceil((booking.startDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)); // Days
        
        if (timeUntilStart <= 1) {
          reminders.push({
            type: "pickup_reminder",
            message: `Reminder: Your rental "${booking.listing.title}" starts tomorrow. Don't forget to pick it up!`,
            bookingId: booking.id,
            priority: 9,
            timeUntilEvent: `${timeUntilStart} day${timeUntilStart !== 1 ? 's' : ''}`
          });
        } else if (timeUntilStart <= 3) {
          reminders.push({
            type: "pickup_reminder",
            message: `Reminder: Your rental "${booking.listing.title}" starts in ${timeUntilStart} days. Plan accordingly!`,
            bookingId: booking.id,
            priority: 8,
            timeUntilEvent: `${timeUntilStart} days`
          });
        }
      }
      
      // Create return reminders
      for (const booking of endingBookings) {
        const timeUntilEnd = Math.ceil((booking.endDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)); // Days
        
        if (timeUntilEnd <= 1) {
          reminders.push({
            type: "return_reminder",
            message: `Reminder: Your rental "${booking.listing.title}" is due back tomorrow. Don't forget to return it!`,
            bookingId: booking.id,
            priority: 9,
            timeUntilEvent: `${timeUntilEnd} day${timeUntilEnd !== 1 ? 's' : ''}`
          });
        } else if (timeUntilEnd <= 3) {
          reminders.push({
            type: "return_reminder",
            message: `Reminder: Your rental "${booking.listing.title}" is due back in ${timeUntilEnd} days. Plan accordingly!`,
            bookingId: booking.id,
            priority: 8,
            timeUntilEvent: `${timeUntilEnd} days`
          });
        }
      }
      
      return reminders;
    } catch (error) {
      console.error('Error getting booking reminders:', error);
      return reminders;
    }
  }

  /**
   * Implement voice interface with voice-activated assistance
   * @param context Current user context
   * @returns Voice interface guidance
   */
  getVoiceInterfaceGuidance(context: AIContext) {
    return {
      activation: [
        "Say 'Hey REN' to activate voice assistance",
        "Speak naturally - I understand conversational language",
        "You can ask questions like 'Find camera rentals near me' or 'List my tools'"
      ],
      features: [
        "Search for rentals using voice commands",
        "List items for rent through voice guidance",
        "Manage bookings and check status updates",
        "Get personalized recommendations",
        "Navigate the platform hands-free"
      ],
      tips: [
        "Speak clearly in a quiet environment for best results",
        "Use specific terms like 'camera', 'tool', or 'party supplies'",
        "You can interrupt me at any time by saying 'Stop' or 'Cancel'",
        "I'll confirm important actions before proceeding"
      ]
    };
  }

  /**
   * Add voice search capabilities
   * @param voiceInput The voice input transcribed to text
   * @param context Current user context
   * @returns Voice search results and suggestions
   */
  async processVoiceSearch(voiceInput: string, context: AIContext) {
    try {
      // Extract entities from voice input
      const entities = this.extractEntities(voiceInput);
      
      // Build search criteria
      const searchCriteria: any = {};
      
      // Add item search criteria
      if (entities?.items?.length) {
        searchCriteria.OR = [
          { title: { contains: entities.items[0], mode: 'insensitive' } },
          { description: { contains: entities.items[0], mode: 'insensitive' } }
        ];
      }
      
      // Add location search criteria
      if (entities?.locations?.length) {
        searchCriteria.location = { contains: entities.locations[0], mode: 'insensitive' };
      }
      
      // Add price range criteria
      if (entities?.prices?.length) {
        // Use the first price as a reference point
        const referencePrice = entities.prices[0];
        searchCriteria.price = {
          gte: referencePrice * 0.7, // 30% below
          lte: referencePrice * 1.3  // 30% above
        };
      }
      
      // Perform the search
      const listings = await prisma.listing.findMany({
        where: searchCriteria,
        take: 5,
        include: {
          owner: {
            select: {
              id: true,
              name: true
            }
          },
          reviews: {
            select: {
              rating: true
            }
          }
        }
      });

      // Calculate average ratings
      const enrichedListings = listings.map(listing => {
        const totalRating = listing.reviews.reduce((sum, review) => sum + review.rating, 0);
        const averageRating = listing.reviews.length > 0 ? totalRating / listing.reviews.length : 0;
        
        return {
          id: listing.id,
          title: listing.title,
          description: listing.description,
          price: listing.price,
          location: listing.location,
          images: JSON.parse(listing.images || '[]'),
          ownerId: listing.ownerId,
          ownerName: listing.owner.name,
          averageRating: averageRating,
          reviewCount: listing.reviews.length,
          createdAt: listing.createdAt
        };
      });

      return {
        results: enrichedListings,
        query: voiceInput,
        entities: entities,
        resultCount: enrichedListings.length
      };
    } catch (error) {
      console.error('Error processing voice search:', error);
      return {
        results: [],
        query: voiceInput,
        entities: null,
        resultCount: 0,
        error: 'Failed to process voice search'
      };
    }
  }

  /**
   * Implement audio responses for accessibility
   * @param responseText The text to convert to audio
   * @param context Current user context
   * @returns Audio response guidance
   */
  getAudioResponseGuidance(responseText: string, context: AIContext) {
    return {
      features: [
        "Text-to-speech for all AI responses",
        "Adjustable speech speed and voice preferences",
        "Audio notifications for important updates",
        "Voice feedback for actions and confirmations"
      ],
      settings: [
        "Choose from multiple voice options",
        "Adjust speech rate (slow, normal, fast)",
        "Enable/disable audio responses",
        "Customize audio notification types"
      ],
      accessibility: [
        "Full compatibility with screen readers",
        "Audio descriptions for visual content",
        "Keyboard navigation support",
        "High contrast mode options"
      ]
    };
  }

  /**
   * Add image-based search and recognition
   * @param imageDescription Description of the image content
   * @param context Current user context
   * @returns Image search results and suggestions
   */
  async processImageSearch(imageDescription: string, context: AIContext) {
    try {
      // Extract entities from image description
      const entities = this.extractEntities(imageDescription);
      
      // Build search criteria based on image content
      const searchCriteria: any = {};
      
      // Add item search criteria
      if (entities?.items?.length) {
        searchCriteria.OR = [
          { title: { contains: entities.items[0], mode: 'insensitive' } },
          { description: { contains: entities.items[0], mode: 'insensitive' } },
          { category: { contains: entities.items[0], mode: 'insensitive' } }
        ];
      }
      
      // Perform the search
      const listings = await prisma.listing.findMany({
        where: searchCriteria,
        take: 5,
        include: {
          owner: {
            select: {
              id: true,
              name: true
            }
          },
          reviews: {
            select: {
              rating: true
            }
          }
        }
      });

      // Calculate average ratings
      const enrichedListings = listings.map(listing => {
        const totalRating = listing.reviews.reduce((sum, review) => sum + review.rating, 0);
        const averageRating = listing.reviews.length > 0 ? totalRating / listing.reviews.length : 0;
        
        return {
          id: listing.id,
          title: listing.title,
          description: listing.description,
          price: listing.price,
          location: listing.location,
          images: JSON.parse(listing.images || '[]'),
          ownerId: listing.ownerId,
          ownerName: listing.owner.name,
          averageRating: averageRating,
          reviewCount: listing.reviews.length,
          createdAt: listing.createdAt
        };
      });

      return {
        results: enrichedListings,
        query: imageDescription,
        entities: entities,
        resultCount: enrichedListings.length
      };
    } catch (error) {
      console.error('Error processing image search:', error);
      return {
        results: [],
        query: imageDescription,
        entities: null,
        resultCount: 0,
        error: 'Failed to process image search'
      };
    }
  }

  /**
   * Implement visual tutorials and guides
   * @param tutorialTopic The topic for the tutorial
   * @param context Current user context
   * @returns Visual tutorial content
   */
  getVisualTutorial(tutorialTopic: string, context: AIContext) {
    const tutorials: {[key: string]: any} = {
      "listing": {
        title: "How to List an Item",
        steps: [
          {
            step: 1,
            title: "Navigate to Listing Page",
            description: "Click on 'List Item' in the navigation menu",
            visual: "screenshot of navigation menu with 'List Item' highlighted"
          },
          {
            step: 2,
            title: "Fill in Item Details",
            description: "Enter title, description, price, and location",
            visual: "screenshot of listing form with example data"
          },
          {
            step: 3,
            title: "Upload Photos",
            description: "Add clear photos of your item from multiple angles",
            visual: "screenshot of photo upload interface"
          },
          {
            step: 4,
            title: "Set Availability",
            description: "Mark dates when your item is available for rent",
            visual: "screenshot of calendar with available dates marked"
          },
          {
            step: 5,
            title: "Publish Listing",
            description: "Review and publish your listing to make it visible",
            visual: "screenshot of publish button and confirmation"
          }
        ]
      },
      "booking": {
        title: "How to Book an Item",
        steps: [
          {
            step: 1,
            title: "Search for Items",
            description: "Use the search bar or browse categories to find items",
            visual: "screenshot of search interface"
          },
          {
            step: 2,
            title: "View Item Details",
            description: "Click on an item to see photos, description, and reviews",
            visual: "screenshot of item detail page"
          },
          {
            step: 3,
            title: "Select Dates",
            description: "Choose your rental dates from the calendar",
            visual: "screenshot of date selection calendar"
          },
          {
            step: 4,
            title: "Confirm Booking",
            description: "Review details and confirm your booking",
            visual: "screenshot of booking confirmation page"
          },
          {
            step: 5,
            title: "Make Payment",
            description: "Complete payment through our secure system",
            visual: "screenshot of payment interface"
          }
        ]
      },
      "messaging": {
        title: "How to Use Messaging",
        steps: [
          {
            step: 1,
            title: "Access Inbox",
            description: "Click on 'Messages' in the navigation menu",
            visual: "screenshot of navigation menu with 'Messages' highlighted"
          },
          {
            step: 2,
            title: "View Conversations",
            description: "See all your conversations with renters and owners",
            visual: "screenshot of conversation list"
          },
          {
            step: 3,
            title: "Send Messages",
            description: "Type your message and click send to communicate",
            visual: "screenshot of message input field"
          },
          {
            step: 4,
            title: "Attach Files",
            description: "Upload photos or documents to share with the other party",
            visual: "screenshot of file attachment interface"
          }
        ]
      }
    };

    return tutorials[tutorialTopic] || {
      title: "Tutorial Not Found",
      steps: [
        {
          step: 1,
          title: "General Help",
          description: "I can help you with listing items, booking rentals, or using platform features. What would you like to learn about?",
          visual: "screenshot of help page"
        }
      ]
    };
  }

  /**
   * Add augmented reality previews for items
   * @param listingId The ID of the listing to preview
   * @param context Current user context
   * @returns AR preview guidance
   */
  async getArPreviewGuidance(listingId: string, context: AIContext) {
    try {
      // Get listing details
      const listing = await prisma.listing.findUnique({
        where: { id: listingId },
        select: {
          id: true,
          title: true,
          description: true,
          images: true,
          dimensions: true,
          category: true
        }
      });

      if (!listing) {
        return {
          error: "Listing not found"
        };
      }

      return {
        listing: {
          id: listing.id,
          title: listing.title,
          description: listing.description,
          images: JSON.parse(listing.images || '[]'),
          dimensions: listing.dimensions || "Dimensions not specified",
          category: listing.category || "General item"
        },
        arFeatures: [
          "View item in your space using camera",
          "See actual size and scale",
          "Rotate and examine from all angles",
          "Compare with similar items",
          "Visualize in different environments"
        ],
        instructions: [
          "Open the RenThing mobile app",
          "Navigate to the item details page",
          "Tap the 'AR Preview' button",
          "Point your camera at the desired location",
          "Adjust position and size as needed"
        ],
        compatibility: [
          "Requires iOS 11+ or Android 8+",
          "Works with most modern smartphones",
          "No additional hardware required",
          "Internet connection recommended for best experience"
        ]
      };
    } catch (error) {
      console.error('Error getting AR preview guidance:', error);
      return {
        error: "Failed to retrieve AR preview information"
      };
    }
  }

  /**
   * Implement SMS integration for notifications
   * @param userId The user ID
   * @param context Current user context
   * @returns SMS notification settings and options
   */
  getSmsNotificationOptions(userId: string, context: AIContext) {
    return {
      notificationTypes: [
        {
          type: "booking_confirmation",
          description: "Get SMS when a booking is confirmed",
          enabledByDefault: true
        },
        {
          type: "payment_reminder",
          description: "Receive payment reminders via SMS",
          enabledByDefault: true
        },
        {
          type: "upcoming_rental",
          description: "SMS reminder before rental starts",
          enabledByDefault: true
        },
        {
          type: "return_reminder",
          description: "Reminder to return items on time",
          enabledByDefault: true
        },
        {
          type: "message_notification",
          description: "SMS when you receive new messages",
          enabledByDefault: false
        }
      ],
      preferences: [
        "Set preferred SMS time (morning, afternoon, evening)",
        "Choose which notifications to receive via SMS",
        "Enable/disable SMS notifications entirely",
        "Update phone number for SMS delivery"
      ],
      tips: [
        "Standard messaging rates may apply",
        "You can unsubscribe at any time by replying 'STOP'",
        "SMS notifications are in addition to email and app notifications",
        "International SMS may have additional charges"
      ]
    };
  }

  /**
   * Add push notifications for mobile users
   * @param context Current user context
   * @returns Push notification settings and options
   */
  getPushNotificationOptions(context: AIContext) {
    return {
      notificationTypes: [
        {
          type: "instant_message",
          description: "Real-time notifications for new messages",
          enabledByDefault: true
        },
        {
          type: "booking_updates",
          description: "Updates on booking status changes",
          enabledByDefault: true
        },
        {
          type: "price_drops",
          description: "Notifications for price drops on wishlist items",
          enabledByDefault: true
        },
        {
          type: "new_listings",
          description: "Alerts for new listings in your preferred categories",
          enabledByDefault: false
        },
        {
          type: "promotions",
          description: "Special offers and platform promotions",
          enabledByDefault: false
        }
      ],
      preferences: [
        "Customize notification sounds",
        "Set quiet hours to avoid notifications",
        "Choose notification priority levels",
        "Enable/disable specific notification types"
      ],
      tips: [
        "Push notifications work even when the app is closed",
        "You can manage notifications in your device settings",
        "Battery optimization may affect notification delivery",
        "Notifications sync across all your devices"
      ]
    };
  }

  /**
   * Implement offline capabilities for basic assistance
   * @param context Current user context
   * @returns Offline assistance capabilities
   */
  getOfflineCapabilities(context: AIContext) {
    return {
      availableFeatures: [
        "View previously loaded listings",
        "Access saved wishlist items",
        "Review booking history",
        "See messaging history",
        "Access basic account information"
      ],
      limitations: [
        "Cannot search for new listings",
        "Cannot send new messages",
        "Cannot make bookings or payments",
        "Cannot update profile information",
        "Cannot list new items"
      ],
      synchronization: [
        "Changes automatically sync when connection is restored",
        "Offline data is stored securely on your device",
        "Up to 30 days of data can be stored offline",
        "Large images and files are not cached offline"
      ],
      tips: [
        "Enable offline mode in settings for better performance",
        "Download important information before going offline",
        "Bookmark key pages for easy offline access",
        "Data is encrypted and secure on your device"
      ]
    };
  }

  /**
   * Get reminders for upcoming bookings or return dates
   * @param userId The user ID to get reminders for
   * @returns Array of booking reminders
   */
  async getBookingReminders(userId: string) {
    const reminders: Array<{type: string, message: string, bookingId: string, priority: number, timeUntilEvent: string}> = [];
    
    try {
      // Get upcoming bookings (within next 7 days)
      const upcomingBookings = await prisma.booking.findMany({
        where: {
          userId: userId,
          startDate: {
            gte: new Date(),
            lte: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // Next 7 days
          },
          status: 'confirmed'
        },
        include: {
          listing: {
            select: {
              title: true
            }
          }
        },
        orderBy: {
          startDate: 'asc'
        }
      });
      
      // Get bookings ending soon (within next 2 days)
      const endingBookings = await prisma.booking.findMany({
        where: {
          userId: userId,
          endDate: {
            gte: new Date(),
            lte: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000) // Next 2 days
          },
          status: 'confirmed'
        },
        include: {
          listing: {
            select: {
              title: true
            }
          }
        },
        orderBy: {
          endDate: 'asc'
        }
      });
      
      // Create pickup reminders
      for (const booking of upcomingBookings) {
        const timeUntilStart = Math.ceil((booking.startDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)); // Days
        
        if (timeUntilStart <= 1) {
          reminders.push({
            type: "pickup_reminder",
            message: `Reminder: Your rental "${booking.listing.title}" starts tomorrow. Don't forget to pick it up!`,
            bookingId: booking.id,
            priority: 9,
            timeUntilEvent: `${timeUntilStart} day${timeUntilStart !== 1 ? 's' : ''}`
          });
        } else if (timeUntilStart <= 3) {
          reminders.push({
            type: "pickup_reminder",
            message: `Reminder: Your rental "${booking.listing.title}" starts in ${timeUntilStart} days. Plan accordingly!`,
            bookingId: booking.id,
            priority: 8,
            timeUntilEvent: `${timeUntilStart} days`
          });
        }
      }
      
      // Create return reminders
      for (const booking of endingBookings) {
        const timeUntilEnd = Math.ceil((booking.endDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)); // Days
        
        if (timeUntilEnd <= 1) {
          reminders.push({
            type: "return_reminder",
            message: `Reminder: Your rental "${booking.listing.title}" is due tomorrow. Don't forget to return it!`,
            bookingId: booking.id,
            priority: 10,
            timeUntilEvent: `${timeUntilEnd} day${timeUntilEnd !== 1 ? 's' : ''}`
          });
        } else if (timeUntilEnd <= 2) {
          reminders.push({
            type: "return_reminder",
            message: `Reminder: Your rental "${booking.listing.title}" is due in ${timeUntilEnd} days. Prepare for return!`,
            bookingId: booking.id,
            priority: 8,
            timeUntilEvent: `${timeUntilEnd} day${timeUntilEnd !== 1 ? 's' : ''}`
          });
        }
      }
      
      // Sort reminders by priority
      return reminders.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error getting booking reminders:', error);
      return reminders;
    }
  }

  /**
   * Generate personalized recommendations for a user
   * @param userId The user ID to generate recommendations for
   * @returns Array of recommended listings
   */
  async generateRecommendations(userId: string) {
    try {
      // Get user's booking history
      const userBookings = await prisma.booking.findMany({
        where: { userId },
        include: { listing: true }
      });
      
      // If no booking history, return trending listings
      if (userBookings.length === 0) {
        return await this.getTrendingListings();
      }

      // Extract categories from past bookings
      const categories = userBookings.map(booking => booking.listing.description);

      // Find similar listings
      const recommendations = await prisma.listing.findMany({
        where: {
          description: {
            in: categories
          }
        },
        take: 5,
        include: {
          owner: {
            select: {
              id: true,
              name: true
            }
          },
          reviews: {
            select: {
              rating: true
            }
          }
        }
      });
      
      // Calculate average ratings
      const enrichedRecommendations = recommendations.map(listing => {
        const totalRating = listing.reviews.reduce((sum, review) => sum + review.rating, 0);
        const averageRating = listing.reviews.length > 0 ? totalRating / listing.reviews.length : 0;
        
        return {
          id: listing.id,
          title: listing.title,
          description: listing.description,
          price: listing.price,
          location: listing.location,
          images: JSON.parse(listing.images || '[]'),
          ownerId: listing.ownerId,
          ownerName: listing.owner.name,
          averageRating: averageRating,
          reviewCount: listing.reviews.length,
          createdAt: listing.createdAt
        };
      });

      return enrichedRecommendations;
    } catch (error) {
      console.error('Error generating recommendations:', error);
      return [];
    }
  }

  /**
   * Generate contextual suggestions based on user activity (public method)
   * @param context Current user context
   * @returns Array of contextual suggestions
   */
  public async generateContextualSuggestions(context: AIContext) {
    return await this.getContextualSuggestions(context);
  }

  /**
   * Help users modify or cancel bookings
   * @param userId The user ID
   * @param context Current user context
   * @returns Array of booking modification assistance suggestions
   */
  async getBookingModificationAssistance(userId: string, context: AIContext) {
    const assistance: Array<{type: string, message: string, bookingId?: string, priority: number}> = [];
    
    try {
      // Get user's upcoming bookings
      const upcomingBookings = await prisma.booking.findMany({
        where: {
          userId: userId,
          startDate: {
            gte: new Date()
          },
          status: {
            in: ['pending', 'confirmed', 'active']
          }
        },
        include: {
          listing: {
            select: {
              id: true,
              title: true,
              price: true
            }
          }
        },
        orderBy: {
          startDate: 'asc'
        }
      });
      
      // Add modification options for each booking
      for (const booking of upcomingBookings) {
        assistance.push({
          type: "modify_booking",
          message: `Modify booking: "${booking.listing.title}" (₱${booking.listing.price}/day) starting ${booking.startDate.toDateString()}`,
          bookingId: booking.id,
          priority: 8
        });
        
        assistance.push({
          type: "cancel_booking",
          message: `Cancel booking: "${booking.listing.title}" starting ${booking.startDate.toDateString()}`,
          bookingId: booking.id,
          priority: 7
        });
      }
      
      // Add general modification help
      assistance.push({
        type: "booking_help",
        message: "Need help with modifying or canceling a booking? I can guide you through the process.",
        priority: 5
      });
      
      // Sort by priority
      return assistance.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error getting booking modification assistance:', error);
      return assistance;
    }
  }

  /**
   * Provide booking status updates
   * @param userId The user ID
   * @param context Current user context
   * @returns Array of booking status updates
   */
  async getBookingStatusUpdates(userId: string, context: AIContext) {
    const updates: Array<{type: string, message: string, bookingId?: string, priority: number}> = [];
    
    try {
      // Get user's recent bookings with status changes
      const recentBookings = await prisma.booking.findMany({
        where: {
          userId: userId,
          updatedAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days
          }
        },
        include: {
          listing: {
            select: {
              id: true,
              title: true
            }
          }
        },
        orderBy: {
          updatedAt: 'desc'
        }
      });
      
      // Add status updates
      for (const booking of recentBookings) {
        const statusMessages: {[key: string]: string} = {
          'pending': 'is awaiting confirmation from the owner',
          'confirmed': 'has been confirmed by the owner',
          'active': 'is currently active',
          'completed': 'has been completed',
          'cancelled': 'has been cancelled',
          'rejected': 'has been rejected by the owner'
        };
        
        const statusMessage = statusMessages[booking.status] || 'status has been updated';
        updates.push({
          type: "booking_status",
          message: `Your booking for "${booking.listing.title}" ${statusMessage}`,
          bookingId: booking.id,
          priority: 8
        });
      }
      
      // Add general booking status help
      updates.push({
        type: "booking_status_help",
        message: "Want to check the status of a specific booking? I can help you find it.",
        priority: 5
      });
      
      // Sort by priority
      return updates.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error getting booking status updates:', error);
      return updates;
    }
  }

  /**
   * Assist with rescheduling when conflicts arise
   * @param userId The user ID
   * @param context Current user context
   * @returns Array of rescheduling assistance suggestions
   */
  async getReschedulingAssistance(userId: string, context: AIContext) {
    const assistance: Array<{type: string, message: string, bookingId?: string, priority: number}> = [];
    
    try {
      // Get user's upcoming bookings that might have conflicts
      const upcomingBookings = await prisma.booking.findMany({
        where: {
          userId: userId,
          startDate: {
            gte: new Date()
          },
          status: {
            in: ['pending', 'confirmed', 'active']
          }
        },
        include: {
          listing: {
            select: {
              id: true,
              title: true,
              price: true
            }
          }
        },
        orderBy: {
          startDate: 'asc'
        }
      });
      
      // Add rescheduling options
      for (const booking of upcomingBookings) {
        assistance.push({
          type: "reschedule_booking",
          message: `Reschedule booking: "${booking.listing.title}" (₱${booking.listing.price}/day)`,
          bookingId: booking.id,
          priority: 8
        });
      }
      
      // Add general rescheduling help
      assistance.push({
        type: "reschedule_help",
        message: "Having a scheduling conflict? I can help you reschedule your booking to different dates.",
        priority: 6
      });
      
      // Sort by priority
      return assistance.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error getting rescheduling assistance:', error);
      return assistance;
    }
  }

  /**
   * Explain payment methods and security measures
   * @param context Current user context
   * @returns Payment information and security details
   */
  getPaymentInformation(context: AIContext) {
    return {
      paymentMethods: [
        {
          name: "Credit/Debit Card",
          description: "Secure payment through our PCI-compliant payment processor",
          security: "All card information is encrypted and processed securely"
        },
        {
          name: "Bank Transfer",
          description: "Direct bank transfers for secure payments",
          security: "Bank-level encryption and fraud protection"
        },
        {
          name: "E-Wallet",
          description: "Digital wallet payments for convenience",
          security: "Two-factor authentication and transaction monitoring"
        }
      ],
      securityMeasures: [
        "End-to-end encryption for all payment data",
        "PCI DSS compliance for card transactions",
        "Fraud detection and prevention systems",
        "Secure payment holding until rental completion",
        "Refund protection policies"
      ],
      tips: [
        "Always verify the item and owner details before confirming payment",
        "Keep all payment receipts and communication records",
        "Report any suspicious activity immediately",
        "Use our secure messaging system for all communication"
      ]
    };
  }

  /**
   * Help troubleshoot payment issues
   * @param context Current user context
   * @returns Array of payment troubleshooting suggestions
   */
  getPaymentTroubleshooting(context: AIContext) {
    return [
      {
        type: "card_declined",
        message: "Card declined? Check if your card has sufficient funds or contact your bank.",
        priority: 9
      },
      {
        type: "payment_failed",
        message: "Payment failed? Try a different payment method or check your internet connection.",
        priority: 8
      },
      {
        type: "transaction_pending",
        message: "Transaction pending? This may take a few minutes. Please wait and check back.",
        priority: 7
      },
      {
        type: "refund_issue",
        message: "Having issues with a refund? Contact our support team with your transaction details.",
        priority: 6
      },
      {
        type: "payment_help",
        message: "Need help with payments? I can guide you through the process step by step.",
        priority: 5
      }
    ].sort((a, b) => b.priority - a.priority);
  }

  /**
   * Provide payment history and transaction details
   * @param userId The user ID
   * @param context Current user context
   * @returns Payment history and transaction details
   */
  async getPaymentHistory(userId: string, context: AIContext) {
    try {
      // Get user's transaction history
      const transactions = await prisma.transaction.findMany({
        where: {
          userId: userId
        },
        include: {
          booking: {
            include: {
              listing: {
                select: {
                  title: true
                }
              }
            }
          }
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 10
      });
      
      // Calculate payment summary
      const totalSpent = transactions
        .filter(t => t.amount > 0)
        .reduce((sum, transaction) => sum + transaction.amount, 0);
      
      const totalEarned = transactions
        .filter(t => t.amount < 0) // Assuming negative amounts represent earnings
        .reduce((sum, transaction) => sum + Math.abs(transaction.amount), 0);
      
      return {
        transactions: transactions.map(t => ({
          id: t.id,
          amount: t.amount,
          currency: t.currency,
          paymentMethod: t.paymentMethod,
          status: t.status,
          createdAt: t.createdAt,
          itemName: t.booking?.listing?.title || 'Unknown item',
          type: t.amount > 0 ? 'payment' : 'earning'
        })),
        summary: {
          totalSpent: totalSpent,
          totalEarned: totalEarned,
          netBalance: totalEarned - totalSpent,
          transactionCount: transactions.length
        }
      };
    } catch (error) {
      console.error('Error getting payment history:', error);
      return {
        transactions: [],
        summary: {
          totalSpent: 0,
          totalEarned: 0,
          netBalance: 0,
          transactionCount: 0
        }
      };
    }
  }

  /**
   * Guide users on leaving helpful reviews
   * @param context Current user context
   * @returns Review guidelines and tips
   */
  getReviewGuidelines(context: AIContext) {
    return {
      guidelines: [
        "Be honest and specific about your experience",
        "Mention both positive aspects and areas for improvement",
        "Focus on the item and rental process, not personal opinions about the owner",
        "Include details about item condition, accuracy of description, and communication",
        "Be respectful and constructive in your feedback"
      ],
      tips: [
        "Include photos if they help illustrate your review",
        "Mention if the item arrived as described",
        "Comment on the owner's responsiveness and helpfulness",
        "Rate based on your actual experience, not expectations",
        "Keep reviews recent and relevant"
      ],
      ratingCriteria: [
        "1 star: Poor experience, significant issues",
        "2 stars: Below average, some problems",
        "3 stars: Average experience, met basic expectations",
        "4 stars: Good experience, minor issues",
        "5 stars: Excellent experience, exceeded expectations"
      ]
    };
  }

  /**
   * Suggest items to review based on recent rentals
   * @param userId The user ID
   * @param context Current user context
   * @returns Array of items to review
   */
  async getSuggestedReviews(userId: string, context: AIContext) {
    const suggestions: Array<{type: string, message: string, listingId?: string, bookingId?: string, priority: number}> = [];
    
    try {
      // Get user's recent completed bookings without reviews
      const recentBookings = await prisma.booking.findMany({
        where: {
          userId: userId,
          status: 'completed',
          endDate: {
            lte: new Date()
          },
          startDate: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
          }
        },
        include: {
          listing: {
            select: {
              id: true,
              title: true
            }
          },
          reviews: true
        },
        orderBy: {
          endDate: 'desc'
        }
      });
      
      // Filter for bookings without reviews
      const bookingsWithoutReviews = recentBookings.filter(booking => booking.reviews.length === 0);
      
      // Add suggestions
      for (const booking of bookingsWithoutReviews) {
        suggestions.push({
          type: "review_suggestion",
          message: `How was your experience with "${booking.listing.title}"? Leave a review to help other renters.`,
          listingId: booking.listing.id,
          bookingId: booking.id,
          priority: 8
        });
      }
      
      // Add general review help
      suggestions.push({
        type: "review_help",
        message: "Want to leave a review? I can guide you through the process.",
        priority: 5
      });
      
      // Sort by priority
      return suggestions.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error getting suggested reviews:', error);
      return suggestions;
    }
  }

  /**
   * Help resolve disputes through mediation suggestions
   * @param context Current user context
   * @returns Dispute resolution guidance
   */
  getDisputeResolutionGuidance(context: AIContext) {
    return {
      steps: [
        "Document all communication and evidence related to the dispute",
        "Try to resolve the issue directly with the other party through our messaging system",
        "If direct communication fails, submit a dispute report through our support system",
        "Provide clear details about the issue and any relevant evidence",
        "Our mediation team will review the case and contact both parties",
        "Follow the mediator's guidance to reach a fair resolution"
      ],
      whenToEscalate: [
        "Safety concerns or threats",
        "Significant item damage or misrepresentation",
        "Payment disputes or fraud",
        "Non-communication after multiple attempts",
        "Violation of platform policies"
      ],
      tips: [
        "Keep all messages and photos as evidence",
        "Be respectful and factual in your communication",
        "Respond promptly to mediator requests",
        "Be open to compromise for mutual benefit",
        "Follow platform guidelines throughout the process"
      ]
    };
  }

  /**
   * System monitoring superpower - scans codebase for issues
   * This is a placeholder for the actual implementation that would integrate with GitHub
   */
  async scanCodebaseForIssues() {
    // In a real implementation, this would:
    // 1. Connect to GitHub API
    // 2. Scan repository files for common issues
    // 3. Analyze code quality metrics
    // 4. Identify potential bugs and security vulnerabilities
    // 5. Generate reports and suggestions

    return {
      issues: [],
      suggestions: [
        "Code scanning feature will be implemented to continuously monitor the codebase for improvements and potential issues."
      ]
    };
  }

  /**
   * Get nearby locations based on a given location using geolocation data
   * @param location The base location
   * @param userLat User's latitude (if available)
   * @param userLng User's longitude (if available)
   * @returns Array of nearby locations
   */
  private async getNearbyLocations(location: string, userLat?: number, userLng?: number): Promise<string[]> {
    try {
      // If we have user's geolocation data, use it to find nearby locations
      if (userLat !== undefined && userLng !== undefined) {
        // In a real implementation, this would call a geolocation service API
        // For example, using Google Places API or similar
        // For now, we'll implement a basic version that could be extended
        
        // This is a placeholder implementation that would be replaced with actual geolocation service
        // For demonstration, we'll return some nearby cities based on known coordinates in the Philippines
        const philippinesCities = [
          { name: "Manila", lat: 14.5995, lng: 120.9842 },
          { name: "Makati", lat: 14.5547, lng: 121.0244 },
          { name: "Taguig", lat: 14.5176, lng: 121.0509 },
          { name: "Pasay", lat: 14.5375, lng: 121.0014 },
          { name: "Quezon City", lat: 14.6379, lng: 121.0434 },
          { name: "Caloocan", lat: 14.7569, lng: 120.9812 },
          { name: "Mandaluyong", lat: 14.5832, lng: 121.0409 },
          { name: "Marikina", lat: 14.6419, lng: 121.1004 },
          { name: "Pasig", lat: 14.5866, lng: 121.0604 },
          { name: "San Juan", lat: 14.5995, lng: 121.0359 },
          { name: "Cebu City", lat: 10.3157, lng: 123.8854 },
          { name: "Mandaue", lat: 10.3234, lng: 123.9294 },
          { name: "Lapu-Lapu", lat: 10.2988, lng: 123.9669 },
          { name: "Davao City", lat: 7.1907, lng: 125.4553 },
          { name: "Iloilo City", lat: 10.7202, lng: 122.5621 }
        ];
        
        // Find the reference location coordinates
        const referenceLocation = philippinesCities.find(city => 
          city.name.toLowerCase() === location.toLowerCase()
        );
        
        if (referenceLocation) {
          // Calculate distances to all other cities and return the closest ones
          const distances = philippinesCities
            .filter(city => city.name.toLowerCase() !== location.toLowerCase())
            .map(city => ({
              name: city.name,
              distance: Math.sqrt(
                Math.pow(city.lat - referenceLocation.lat, 2) + 
                Math.pow(city.lng - referenceLocation.lng, 2)
              )
            }))
            .sort((a, b) => a.distance - b.distance)
            .slice(0, 5) // Return top 5 nearest locations
            .map(city => city.name);
            
          return distances;
        }
      }
      
      // Fallback to the original hardcoded map for common locations
      const nearbyLocationsMap: Record<string, string[]> = {
        "Manila": ["Makati", "Taguig", "Pasay", "Quezon City", "Caloocan"],
        "Makati": ["Manila", "Taguig", "Pasay", "Quezon City", "Mandaluyong"],
        "Taguig": ["Manila", "Makati", "Pasay", "Mandaluyong", "Pasig"],
        "Quezon City": ["Manila", "Makati", "Caloocan", "San Juan", "Mandaluyong"],
        "Pasig": ["Manila", "Makati", "Taguig", "Mandaluyong", "Marikina"],
        "Cebu City": ["Mandaue", "Lapu-Lapu", "Talisay", "Naga", "Toledo"],
        "Davao City": ["Davao del Sur", "Davao Oriental", "Davao de Oro", "Tagum", "Panabo"],
        "Iloilo City": ["Iloilo", "Passi", "Santa Barbara", "Tigbauan", "Pototan"]
      };
      
      return nearbyLocationsMap[location] || [];
    } catch (error) {
      console.error('Error getting nearby locations:', error);
      // Fallback to the original hardcoded map
      const nearbyLocationsMap: Record<string, string[]> = {
        "Manila": ["Makati", "Taguig", "Pasay", "Quezon City", "Caloocan"],
        "Makati": ["Manila", "Taguig", "Pasay", "Quezon City", "Mandaluyong"],
        "Taguig": ["Manila", "Makati", "Pasay", "Mandaluyong", "Pasig"],
        "Quezon City": ["Manila", "Makati", "Caloocan", "San Juan", "Mandaluyong"],
        "Pasig": ["Manila", "Makati", "Taguig", "Mandaluyong", "Marikina"],
        "Cebu City": ["Mandaue", "Lapu-Lapu", "Talisay", "Naga", "Toledo"],
        "Davao City": ["Davao del Sur", "Davao Oriental", "Davao de Oro", "Tagum", "Panabo"],
        "Iloilo City": ["Iloilo", "Passi", "Santa Barbara", "Tigbauan", "Pototan"]
      };
      
      return nearbyLocationsMap[location] || [];
    }
  }

  /**
   * Get user's calendar events for rental suggestions
   * @param userId The user ID to get calendar events for
   * @returns Array of calendar events
   */
  private async getUserCalendarEvents(userId: string): Promise<CalendarEvent[]> {
    try {
      // In a real implementation, this would fetch from Google Calendar API or similar
      // For now, we'll return mock data based on user's booking history
      const userBookings = await prisma.booking.findMany({
        where: { userId },
        include: { 
          listing: {
            select: {
              title: true,
              description: true,
              category: true,
              location: true
            }
          }
        },
        orderBy: { startDate: 'asc' }
      });

      // Convert bookings to calendar events
      const calendarEvents: CalendarEvent[] = userBookings.map(booking => ({
        id: booking.id,
        title: `Rent: ${booking.listing.title}`,
        start: booking.startDate,
        end: booking.endDate,
        description: booking.listing.description,
        location: booking.listing.location,
        category: booking.listing.category || 'rental'
      }));

      return calendarEvents;
    } catch (error) {
      console.error('Error getting user calendar events:', error);
      return [];
    }
  }

  /**
   * Get rental suggestions based on calendar events
   * @param userId The user ID to get suggestions for
   * @param context Current AI context
   * @returns Array of rental suggestions based on calendar events
   */
  private async getCalendarBasedSuggestions(userId: string, context: AIContext): Promise<Array<{type: string, message: string, listingId?: string, priority: number}>> {
    const suggestions: Array<{type: string, message: string, listingId?: string, priority: number}> = [];
    
    try {
      // Get user's calendar events
      const calendarEvents = await this.getUserCalendarEvents(userId);
      
      if (calendarEvents.length === 0) {
        return suggestions;
      }
      
      // Get user's persona for personalization
      const persona = await this.generateUserPersona(userId);
      if (!persona) {
        return suggestions;
      }
      
      // Look for upcoming events that might need rentals
      const now = new Date();
      const nextWeek = new Date();
      nextWeek.setDate(now.getDate() + 7);
      
      const upcomingEvents = calendarEvents.filter(event => 
        event.start >= now && event.start <= nextWeek
      );
      
      // For each upcoming event, suggest relevant rentals
      for (const event of upcomingEvents) {
        // Extract keywords from event title and description
        const eventText = `${event.title} ${event.description || ''}`.toLowerCase();
        
        // Determine event type based on keywords
        let eventType = 'general';
        if (eventText.includes('wedding') || eventText.includes('reception')) {
          eventType = 'wedding';
        } else if (eventText.includes('birthday') || eventText.includes('party')) {
          eventType = 'party';
        } else if (eventText.includes('camping') || eventText.includes('hiking')) {
          eventType = 'outdoor';
        } else if (eventText.includes('conference') || eventText.includes('meeting')) {
          eventType = 'business';
        } else if (eventText.includes('beach') || eventText.includes('pool')) {
          eventType = 'beach';
        }
        
        // Suggest rentals based on event type
        switch (eventType) {
          case 'wedding':
            suggestions.push({
              type: "calendar_suggestion",
              message: `Upcoming wedding: Consider renting party decorations, sound systems, or photography equipment for your event on ${event.start.toLocaleDateString()}`,
              priority: 9
            });
            break;
          case 'party':
            suggestions.push({
              type: "calendar_suggestion",
              message: `Upcoming party: Consider renting party supplies, sound systems, or serving equipment for your event on ${event.start.toLocaleDateString()}`,
              priority: 8
            });
            break;
          case 'outdoor':
            suggestions.push({
              type: "calendar_suggestion",
              message: `Upcoming outdoor activity: Consider renting camping gear, sports equipment, or outdoor cooking supplies for your event on ${event.start.toLocaleDateString()}`,
              priority: 8
            });
            break;
          case 'business':
            suggestions.push({
              type: "calendar_suggestion",
              message: `Upcoming business event: Consider renting presentation equipment, office supplies, or professional attire for your event on ${event.start.toLocaleDateString()}`,
              priority: 7
            });
            break;
          case 'beach':
            suggestions.push({
              type: "calendar_suggestion",
              message: `Upcoming beach day: Consider renting beach chairs, umbrellas, or water sports equipment for your event on ${event.start.toLocaleDateString()}`,
              priority: 8
            });
            break;
          default:
            // For general events, suggest based on user's rental history
            if (persona.favoriteCategories.length > 0) {
              const category = persona.favoriteCategories[0];
              suggestions.push({
                type: "calendar_suggestion",
                message: `Upcoming event: Consider renting ${category} items for your event on ${event.start.toLocaleDateString()}`,
                priority: 6
              });
            } else {
              suggestions.push({
                type: "calendar_suggestion",
                message: `Upcoming event: Browse rentals for your event on ${event.start.toLocaleDateString()}`,
                priority: 5
              });
            }
        }
      }
      
      // Sort suggestions by priority
      return suggestions.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error getting calendar-based suggestions:', error);
      return suggestions;
    }
  }

  /**
   * Generate contextual suggestions based on user activity
   * @param context Current user context
   * @returns Array of contextual suggestions
   */
  private async getContextualSuggestions(context: AIContext) {
    const suggestions = [];

    // Use inferred preferences if available
    if (context.inferredPreferences) {
      // Suggest based on preferred categories
      if (context.inferredPreferences.preferredCategories?.length) {
        suggestions.push(`Find more ${context.inferredPreferences.preferredCategories[0]} rentals`);
      }
      
      // Suggest based on preferred locations
      if (context.inferredPreferences.preferredLocations?.length) {
        suggestions.push(`Find rentals in ${context.inferredPreferences.preferredLocations[0]}`);
      }
      
      // Suggest based on engagement level
      if (context.inferredPreferences.engagementLevel === 'high') {
        suggestions.push("You're a frequent renter! Consider listing your own items");
      } else if (context.inferredPreferences.engagementLevel === 'low') {
        suggestions.push("New to renting? Check out our beginner's guide");
      }
    }

    // If user is on browse page, suggest search filters
    if (context.userPreferences?.categories?.length) {
      suggestions.push(`Find more ${context.userPreferences.categories[0]} rentals`);
    }

    // Personalized suggestions based on user profile
    if (context.userProfile) {
      // Suggest based on favorite categories
      if (context.userProfile.favoriteCategories?.length) {
        suggestions.push(`Find more ${context.userProfile.favoriteCategories[0]} items`);
      }
      
      // Suggest based on rental history
      if (context.userProfile.rentalHistory?.length) {
        const recentRental = context.userProfile.rentalHistory[context.userProfile.rentalHistory.length - 1];
        suggestions.push("Rent similar items");
        suggestions.push("Leave a review for your recent rental");
      }
      
      // Suggest based on listed items
      if (context.userProfile.listedItems?.length) {
        suggestions.push("View my listings");
        suggestions.push("Check listing performance");
      }
      
      // Calendar-based suggestions
      if (context.userProfile.calendarEvents?.length) {
        const upcomingEvents = context.userProfile.calendarEvents.filter(event => 
          event.start >= new Date()
        );
        
        if (upcomingEvents.length > 0) {
          const nextEvent = upcomingEvents[0];
          suggestions.push(`Prepare for ${nextEvent.title} on ${nextEvent.start.toLocaleDateString()}`);
        }
      }
    }

    // Location-based suggestions using geolocation data
    if (context.currentLocation) {
      suggestions.push(`Find rentals near ${context.currentLocation}`);
    }
    
    if (context.userPreferences?.locations?.length) {
      suggestions.push(`Find rentals in ${context.userPreferences.locations[0]}`);
    }
    
    // Enhanced location-based suggestions with geolocation data
    if (context.userProfile?.preferredLocations?.length) {
      const preferredLocation = context.userProfile.preferredLocations[0];
      suggestions.push(`Find rentals in ${preferredLocation}`);
      
      // Add nearby location suggestions using geolocation data if available
      const nearbyLocations = await this.getNearbyLocations(
        preferredLocation, 
        context.currentGeolocation?.latitude, 
        context.currentGeolocation?.longitude
      );
      if (nearbyLocations.length > 0) {
        suggestions.push(`Find rentals near ${nearbyLocations[0]}`);
      }
    }

    // Enhanced Seasonal suggestions with personalization
    const currentMonth = new Date().getMonth();
    const currentDate = new Date();
    
    // Get user preferences for seasonal suggestions
    let userPreferredCategories: string[] = [];
    
    if (context.userId) {
      try {
        const userPreferences = await this.getUserPreferences(context.userId);
        userPreferredCategories = userPreferences.preferredCategories || [];
      } catch (error) {
        console.error('Error getting user preferences for seasonal suggestions:', error);
      }
    }
    
    // Enhanced seasonal items with personalization
    const seasonalItems = {
      0: [ // January - New Year
        { item: "Party supplies for New Year celebrations", categories: ["party", "celebration", "event"] },
        { item: "Fitness equipment for New Year resolutions", categories: ["sports", "fitness", "health"] },
        { item: "Winter clothing and accessories", categories: ["clothing", "fashion", "winter"] }
      ],
      1: [ // February - Valentine's Day
        { item: "Valentine's Day gifts and decorations", categories: ["gift", "decoration", "romance"] },
        { item: "Romantic dinner setup items", categories: ["kitchen", "dining", "romance"] },
        { item: "Couples activities and games", categories: ["game", "entertainment", "romance"] }
      ],
      2: [ // March - Spring/Easter
        { item: "Gardening tools for spring planting", categories: ["garden", "outdoor", "tool"] },
        { item: "Spring cleaning supplies", categories: ["cleaning", "home", "utility"] },
        { item: "Easter party items", categories: ["party", "celebration", "event"] }
      ],
      3: [ // April - Summer preparation
        { item: "Umbrellas and rain gear for rainy season", categories: ["weather", "outdoor", "utility"] },
        { item: "Summer sports equipment", categories: ["sports", "outdoor", "recreation"] },
        { item: "Grilling and BBQ equipment", categories: ["kitchen", "outdoor", "cooking"] }
      ],
      4: [ // May - Summer activities
        { item: "Beach and swimming gear", categories: ["beach", "swimming", "outdoor"] },
        { item: "Summer party supplies", categories: ["party", "celebration", "event"] },
        { item: "Outdoor cooking equipment", categories: ["kitchen", "outdoor", "cooking"] }
      ],
      5: [ // June - Mid-year celebrations
        { item: "Independence Day decorations", categories: ["decoration", "celebration", "event"] },
        { item: "Summer vacation rentals", categories: ["travel", "outdoor", "recreation"] },
        { item: "School supplies", categories: ["education", "office", "study"] }
      ],
      6: [ // July - Back-to-school
        { item: "Back-to-school supplies", categories: ["education", "office", "study"] },
        { item: "Study aids and learning tools", categories: ["education", "study", "technology"] },
        { item: "Back-to-school clothing", categories: ["clothing", "fashion", "school"] }
      ],
      7: [ // August - Rainy season
        { item: "Rain gear and waterproof items", categories: ["weather", "outdoor", "utility"] },
        { item: "Indoor entertainment", categories: ["game", "entertainment", "home"] },
        { item: "Home improvement tools", categories: ["home", "tool", "utility"] }
      ],
      8: [ // September - Harvest season
        { item: "Harvest celebration items", categories: ["celebration", "event", "decoration"] },
        { item: "Fall gardening tools", categories: ["garden", "outdoor", "tool"] },
        { item: "Preservation equipment", categories: ["kitchen", "food", "utility"] }
      ],
      9: [ // October - Halloween
        { item: "Halloween costumes and accessories", categories: ["costume", "celebration", "fashion"] },
        { item: "Halloween decorations", categories: ["decoration", "celebration", "event"] },
        { item: "Horror movie equipment", categories: ["entertainment", "media", "technology"] }
      ],
      10: [ // November - Thanksgiving/All Saints
        { item: "Thanksgiving dinner supplies", categories: ["kitchen", "dining", "cooking"] },
        { item: "Family gathering items", categories: ["party", "celebration", "event"] },
        { item: "All Saints' Day decorations", categories: ["decoration", "celebration", "event"] }
      ],
      11: [ // December - Christmas
        { item: "Christmas decorations", categories: ["decoration", "celebration", "event"] },
        { item: "Holiday party supplies", categories: ["party", "celebration", "event"] },
        { item: "Gift wrapping materials", categories: ["gift", "party", "utility"] }
      ]
    };
    
    // Get seasonal suggestions for current month
    const monthSuggestions = seasonalItems[currentMonth as keyof typeof seasonalItems] || [];
    
    // Find the most relevant seasonal suggestion based on user preferences
    let bestSeasonalSuggestion = null;
    let highestMatchScore = 0;
    
    // If user has preferred categories, find the best match
    if (userPreferredCategories.length > 0) {
      for (const suggestion of monthSuggestions) {
        let matchScore = 0;
        
        // Calculate match score based on category overlap
        for (const category of suggestion.categories) {
          if (userPreferredCategories.some(prefCat => 
            prefCat.toLowerCase().includes(category) || 
            category.toLowerCase().includes(prefCat.toLowerCase())
          )) {
            matchScore++;
          }
        }
        
        if (matchScore > highestMatchScore) {
          highestMatchScore = matchScore;
          bestSeasonalSuggestion = suggestion.item;
        }
      }
    }
    
    // If no personalized match found, use the first suggestion
    if (!bestSeasonalSuggestion && monthSuggestions.length > 0) {
      bestSeasonalSuggestion = monthSuggestions[0].item;
    }
    
    // Add seasonal suggestion if available
    if (bestSeasonalSuggestion) {
      suggestions.push(bestSeasonalSuggestion);
    }

    // If user has recent bookings, suggest related actions
    if (context.userId) {
      const recentBookings = await prisma.booking.count({
        where: {
          userId: context.userId,
          createdAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days
          }
        }
      });

      if (recentBookings > 0) {
        suggestions.push("Check booking status");
        suggestions.push("Leave a review for recent rentals");
      }
      
      // Check if user has wishlist items
      const wishlistCount = await prisma.wishlist.count({
        where: {
          userId: context.userId
        }
      });
      
      if (wishlistCount > 0) {
        suggestions.push("View my wishlist");
      }
      
      // Check if user has unread messages
      const unreadMessages = await prisma.message.count({
        where: {
          receiverId: context.userId,
          read: false
        }
      });
      
      if (unreadMessages > 0) {
        suggestions.push(`Check messages (${unreadMessages} unread)`);
      }
      
      // Time-based suggestions
      const currentHour = new Date().getHours();
      const currentDay = new Date().toLocaleDateString('en-US', { weekday: 'long' });
      
      // Get user preferences for time-based suggestions
      let userPreferredHours: number[] = [];
      let userPreferredDays: string[] = [];
      
      if (context.userId) {
        try {
          const userPreferences = await this.getUserPreferences(context.userId);
          userPreferredHours = userPreferences.preferredBookingHours || [];
          userPreferredDays = userPreferences.preferredBookingDays || [];
        } catch (error) {
          console.error('Error getting user preferences for time-based suggestions:', error);
        }
      }
      
      // Enhanced time-based suggestions
      if (userPreferredHours.length > 0 && userPreferredHours.includes(currentHour)) {
        // User has preferred hours and it's one of them
        suggestions.push("It's your preferred time to browse rentals!");
      } else if (currentHour >= 18 && currentHour <= 24) {
        suggestions.push("List an item for rent");
      } else if (currentHour >= 9 && currentHour <= 17) {
        suggestions.push("Browse items for your next project");
      }
      
      // Day-based suggestions
      if (userPreferredDays.length > 0 && userPreferredDays.includes(currentDay)) {
        // User has preferred days and it's one of them
        suggestions.push(`It's your preferred ${currentDay}! Check out new listings.`);
      }
      
      // Weekend vs weekday suggestions
      if (currentDay === 'Saturday' || currentDay === 'Sunday') {
        suggestions.push("Weekend special: Find party supplies and recreational equipment");
      } else {
        suggestions.push("Weekday deals: Find tools and equipment for your projects");
      }

      // Calendar-based rental suggestions
      const calendarSuggestions = await this.getCalendarBasedSuggestions(context.userId, context);
      calendarSuggestions.forEach(suggestion => {
        suggestions.push(suggestion.message);
      });
    }

    // Event-triggered suggestions with enhanced personalization
    if (context.currentSession?.actionsTaken) {
      const actions = context.currentSession.actionsTaken;
      
      // If user has viewed multiple listings, suggest saving to wishlist
      const viewActions = actions.filter(action => action.includes('view_listing')).length;
      if (viewActions >= 3) {
        suggestions.push("Save items to your wishlist");
      }
      
      // If user has searched multiple times, suggest refining search
      const searchActions = actions.filter(action => action.includes('search')).length;
      if (searchActions >= 2) {
        suggestions.push("Try refining your search with filters");
      }
      
      // If user is on a listing page, suggest related actions
      if (context.currentSession.currentPage?.includes('/listing/')) {
        suggestions.push("Book this item now");
        suggestions.push("Ask owner a question");
      }
      
      // Enhanced event-triggered suggestions based on user behavior patterns
      // Detect if user is researching for a specific purpose
      const bookingRelatedActions = actions.filter(action => 
        action.includes('booking') || action.includes('calendar') || action.includes('date')
      ).length;
      
      const listingRelatedActions = actions.filter(action => 
        action.includes('listing') || action.includes('create') || action.includes('add_item')
      ).length;
      
      // If user is actively looking to book, suggest booking assistance
      if (bookingRelatedActions >= 2) {
        suggestions.push("Need help with booking? I can assist you with the process");
      }
      
      // If user is looking to list items, suggest listing assistance
      if (listingRelatedActions >= 2) {
        suggestions.push("Need help listing your items? I can guide you through the process");
      }
      
      // Detect abandoned workflows
      const recentActions = actions.slice(-5); // Last 5 actions
      const startedBooking = recentActions.some(action => action.includes('start_booking'));
      const completedBooking = recentActions.some(action => action.includes('complete_booking'));
      
      if (startedBooking && !completedBooking) {
        suggestions.push("Continue your booking process");
      }
      
      const startedListing = recentActions.some(action => action.includes('start_listing'));
      const completedListing = recentActions.some(action => action.includes('complete_listing'));
      
      if (startedListing && !completedListing) {
        suggestions.push("Continue creating your listing");
      }
      
      // Proactive suggestions for next steps in workflows
      if (context.conversationState?.workflow) {
        const workflow = context.conversationState.workflow;
        const step = context.conversationState.step || 0;
        
        switch (workflow) {
          case 'booking':
            if (step === 0) {
              suggestions.push("Select rental dates");
              suggestions.push("Check availability");
            } else if (step === 1) {
              suggestions.push("Review booking details");
              suggestions.push("Proceed to payment");
            } else if (step === 2) {
              suggestions.push("Complete payment");
              suggestions.push("View booking confirmation");
            }
            break;
          case 'listing':
            if (step === 0) {
              suggestions.push("Add item details");
              suggestions.push("Set rental price");
            } else if (step === 1) {
              suggestions.push("Add photos");
              suggestions.push("Set availability");
            } else if (step === 2) {
              suggestions.push("Review listing");
              suggestions.push("Publish listing");
            }
            break;
          case 'search':
            if (step === 0) {
              suggestions.push("Refine search criteria");
              suggestions.push("Apply filters");
            } else if (step === 1) {
              suggestions.push("Sort results");
              suggestions.push("Save to wishlist");
            }
            break;
        }
      }
      
      // Personalized event-triggered suggestions based on user profile
      if (context.userId) {
        // Get user's rental history to personalize suggestions
        const userBookings = await prisma.booking.findMany({
          where: { userId: context.userId },
          include: { 
            listing: {
              select: {
                category: true,
                title: true
              }
            }
          },
          orderBy: { startDate: 'desc' },
          take: 5 // Last 5 bookings
        });
        
        // Get user's listed items
        const userListings = await prisma.listing.findMany({
          where: { ownerId: context.userId },
          select: {
            category: true,
            title: true
          },
          orderBy: { createdAt: 'desc' },
          take: 5 // Last 5 listings
        });
        
        // Suggest related items based on rental history
        if (userBookings.length > 0) {
          const lastBooking = userBookings[0];
          const lastCategory = lastBooking.listing.category;
          
          if (lastCategory) {
            suggestions.push(`Need more ${lastCategory} items?`);
            suggestions.push(`Rent similar items to ${lastBooking.listing.title}`);
          }
          
          // Suggest complementary items
          const complementaryItems: Record<string, string[]> = {
            'camera': ['tripod', 'lens', 'memory card'],
            'tool': ['safety equipment', 'storage case', 'accessories'],
            'party': ['decorations', 'sound system', 'serving equipment'],
            'sports': ['protective gear', 'accessories', 'training equipment'],
            'outdoor': ['camping gear', 'safety equipment', 'storage'],
            'kitchen': ['utensils', 'serving equipment', 'cleaning supplies']
          };
          
          const categoryKey = Object.keys(complementaryItems).find(key => 
            lastCategory?.toLowerCase().includes(key)
          );
          
          if (categoryKey) {
            const items = complementaryItems[categoryKey];
            if (items.length > 0) {
              suggestions.push(`Need ${items[0]} to go with your ${lastCategory}?`);
            }
          }
        }
        
        // Suggest maintenance for listed items
        if (userListings.length > 0) {
          const lastListing = userListings[0];
          const lastCategory = lastListing.category;
          
          if (lastCategory) {
            suggestions.push(`Maintain your ${lastCategory} items for better rentals`);
          }
        }
      }
    }

    // Maintenance recommendations for listed items
    if (context.userId && context.userProfile?.listedItems?.length) {
      const maintenanceRecommendations = await this.getMaintenanceRecommendations(context.userId);
      maintenanceRecommendations.forEach(recommendation => {
        suggestions.push(recommendation.message);
      });
    }

    // Seasonal listing suggestions for owners
    if (context.userId && context.userProfile?.listedItems?.length) {
      const seasonalSuggestions = await this.getSeasonalListingSuggestions(context.userId);
      seasonalSuggestions.forEach(suggestion => {
        suggestions.push(suggestion.message);
      });
    }

    // Add general suggestions
    suggestions.push("Find popular rentals");
    suggestions.push("View trending items");
    suggestions.push("Import listings from web");

    return suggestions.slice(0, 4); // Limit to 4 suggestions
  }

  /**
   * Generate user persona based on rental history and behavior
   * @param userId The user ID to generate persona for
   * @returns User persona object
   */
  async generateUserPersona(userId: string) {
    try {
      // Get user's booking history
      const userBookings = await prisma.booking.findMany({
        where: { userId },
        include: { 
          listing: {
            select: {
              id: true,
              title: true,
              description: true,
              price: true,
              category: true
            }
          }
        },
        orderBy: { startDate: 'asc' }
      });

      // Extract categories from past bookings
      const categories = userBookings.map(booking => booking.listing.category);

      // Determine user type based on booking frequency
      const bookingCount = userBookings.length;
      let userType = 'casual';
      if (bookingCount >= 10) {
        userType = 'power_user';
      } else if (bookingCount >= 3) {
        userType = 'active';
      }

      // Determine engagement level based on recent activity
      const recentBookings = userBookings.filter(booking => 
        booking.startDate >= new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
      );
      const engagementLevel = recentBookings.length > 0 ? 'high' : 'low';

      // Calculate user tenure in days
      const firstBooking = userBookings[0];
      const tenureDays = firstBooking ? Math.floor((Date.now() - firstBooking.startDate.getTime()) / (1000 * 60 * 60 * 24)) : 0;

      // Get user's favorite categories
      const favoriteCategories = Array.from(new Set(categories));

      // Get user's calendar events
      const calendarEvents = await this.getUserCalendarEvents(userId);

      return {
        userType,
        engagementLevel,
        tenureDays,
        favoriteCategories,
        calendarEvents
      };
    } catch (error) {
      console.error('Error generating user persona:', error);
      return null;
    }
  }

  /**
   * Generate detailed user persona based on rental history and behavior patterns
   * @param userId The user ID to generate persona for
   * @returns Detailed user persona object
   */
  async generateDetailedUserPersona(userId: string) {
    try {
      // Get user's booking history
      const userBookings = await prisma.booking.findMany({
        where: { userId },
        include: { 
          listing: {
            select: {
              id: true,
              title: true,
              description: true,
              price: true,
              category: true
            }
          }
        },
        orderBy: { createdAt: 'asc' }
      });

      // Get user's listed items
      const userListings = await prisma.listing.findMany({
        where: { ownerId: userId },
        select: {
          id: true,
          title: true,
          description: true,
          price: true,
          category: true,
          createdAt: true
        }
      });

      // Get user's wishlist items
      const userWishlist = await prisma.wishlist.findMany({
        where: { userId },
        include: {
          listing: {
            select: {
              id: true,
              title: true,
              description: true,
              price: true,
              category: true
            }
          }
        }
      });

      // Get user's reviews
      const userReviews = await prisma.review.findMany({
        where: { userId },
        include: {
          listing: {
            select: {
              id: true,
              title: true
            }
          }
        }
      });

      // Analyze booking patterns
      const categoriesRented = userBookings.map(booking => booking.listing.category || booking.listing.description);
      const favoriteCategories = [...new Set(categoriesRented)].filter(Boolean);
      
      // Analyze listing patterns
      const categoriesListed = userListings.map(listing => listing.category || listing.description);
      const listedCategories = [...new Set(categoriesListed)].filter(Boolean);
      
      // Analyze price preferences
      const rentedPrices = userBookings.map(booking => booking.listing.price);
      const listedPrices = userListings.map(listing => listing.price);
      const allPrices = [...rentedPrices, ...listedPrices].filter(Boolean);
      
      const priceRange = allPrices.length > 0 ? {
        min: Math.min(...allPrices),
        max: Math.max(...allPrices)
      } : { min: 0, max: 0 };

      // Determine user type
      let userType = 'casual';
      if (userBookings.length > 10 && userListings.length > 5) {
        userType = 'power_user';
      } else if (userBookings.length > 5 || userListings.length > 3) {
        userType = 'active';
      }

      // Determine engagement level
      const totalInteractions = userBookings.length + userListings.length + userWishlist.length + userReviews.length;
      const engagementLevel = totalInteractions > 20 ? 'high' : totalInteractions > 10 ? 'medium' : 'low';

      // Calculate user tenure
      const joinDate = userListings.length > 0 
        ? new Date(Math.min(...userListings.map(l => l.createdAt.getTime()))) 
        : userBookings.length > 0 
          ? userBookings[0].createdAt 
          : new Date();
      
      const tenureDays = Math.floor((Date.now() - joinDate.getTime()) / (1000 * 60 * 60 * 24));

      return {
        userId,
        userType,
        engagementLevel,
        joinDate,
        tenureDays,
        favoriteCategories,
        listedCategories,
        priceRange,
        totalBookings: userBookings.length,
        totalListings: userListings.length,
        totalWishlistItems: userWishlist.length,
        totalReviews: userReviews.length,
        preferredCategories: [...new Set([...favoriteCategories, ...listedCategories])],
        lastActivity: userBookings.length > 0 
          ? userBookings[userBookings.length - 1].createdAt 
          : userListings.length > 0 
            ? userListings[userListings.length - 1].createdAt 
            : new Date()
      };
    } catch (error) {
      console.error('Error generating detailed user persona:', error);
      return null;
    }
  }

  /**
   * Get preferred time slots based on booking hours
   * @param hours Array of booking hours (0-23)
   * @returns Record of time slots with frequency counts
   */
  private getPreferredTimeSlots(hours: number[]): Record<string, number> {
    const slots = {
      morning: 0,    // 6-11 AM
      afternoon: 0,  // 12-5 PM
      evening: 0,    // 6-11 PM
      night: 0       // 12-5 AM
    };

    hours.forEach(hour => {
      if (hour >= 6 && hour <= 11) {
        slots.morning++;
      } else if (hour >= 12 && hour <= 17) {
        slots.afternoon++;
      } else if (hour >= 18 && hour <= 23) {
        slots.evening++;
      } else {
        slots.night++;
      }
    });

    return slots;
  }

  /**
   * Get preferred days based on booking days
   * @param days Array of booking days (0-6, Sunday-Saturday)
   * @returns Record of days with frequency counts
   */
  private getPreferredDays(days: number[]): Record<string, number> {
    const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
    const preferredDays: Record<string, number> = {};

    days.forEach(day => {
      const dayName = dayNames[day];
      preferredDays[dayName] = (preferredDays[dayName] || 0) + 1;
    });

    return preferredDays;
  }

  /**
   * Get seasonal preferences based on booking months
   * @param months Array of booking months (0-11)
   * @returns Record of seasons with frequency counts
   */
  private getSeasonalPreferences(months: number[]): Record<string, number> {
    const seasons = {
      spring: 0,  // March-May
      summer: 0,  // June-August
      autumn: 0,  // September-November
      winter: 0   // December-February
    };

    months.forEach(month => {
      if (month >= 2 && month <= 4) {
        seasons.spring++;
      } else if (month >= 5 && month <= 7) {
        seasons.summer++;
      } else if (month >= 8 && month <= 10) {
        seasons.autumn++;
      } else {
        seasons.winter++;
      }
    });

    return seasons;
  }

  /**
   * Identify behavioral patterns from user data
   * @param user User data with all activities
   * @returns Object with identified behavioral patterns
   */
  private identifyBehavioralPatterns(user: any): Record<string, string> {
    const patterns: Record<string, string> = {};

    // Quick decision maker (books within 24 hours of viewing)
    const quickBookings = user.bookings.filter((booking: any) => {
      const timeDiff = booking.createdAt.getTime() - booking.listing.createdAt.getTime();
      return timeDiff <= 24 * 60 * 60 * 1000; // 24 hours
    });
    
    if (quickBookings.length > user.bookings.length * 0.3) {
      patterns.decisionMaking = 'quick_decision_maker';
    } else if (quickBookings.length > user.bookings.length * 0.1) {
      patterns.decisionMaking = 'moderate_decision_maker';
    } else {
      patterns.decisionMaking = 'deliberate_decision_maker';
    }

    // Review behavior
    if (user.reviews.length === 0) {
      patterns.reviewBehavior = 'non_reviewer';
    } else if (user.reviews.length > user.bookings.length * 0.7) {
      patterns.reviewBehavior = 'active_reviewer';
    } else {
      patterns.reviewBehavior = 'selective_reviewer';
    }

    // Wishlist behavior
    if (user.wishlist.length === 0) {
      patterns.wishlistBehavior = 'non_wishlist_user';
    } else if (user.wishlist.length > 10) {
      patterns.wishlistBehavior = 'heavy_wishlist_user';
    } else {
      patterns.wishlistBehavior = 'moderate_wishlist_user';
    }

    // Listing behavior
    if (user.listings.length === 0) {
      patterns.listingBehavior = 'renter_only';
    } else if (user.listings.length > user.bookings.length) {
      patterns.listingBehavior = 'owner_focused';
    } else if (user.listings.length === user.bookings.length) {
      patterns.listingBehavior = 'balanced_renter_owner';
    } else {
      patterns.listingBehavior = 'renter_focused';
    }

    return patterns;
  }

  /**
   * Get personalized recommendations for a user based on their persona
   * @param userId The user ID to get recommendations for
   * @returns Array of recommended listings
   */
  async getPersonalizedRecommendations(userId: string) {
    try {
      // Generate user persona
      const persona = await this.generateUserPersona(userId);
      if (!persona) {
        return await this.getTrendingListings();
      }

      // Get user's booking history and preferences
      const userBookings = await prisma.booking.findMany({
        where: { userId },
        include: { listing: true }
      });

      // If no booking history, return trending listings
      if (userBookings.length === 0) {
        return await this.getTrendingListings();
      }

      // Extract categories from past bookings
      const categories = userBookings.map(booking => booking.listing.description);

      // Find similar listings with personalization
      const recommendations = await prisma.listing.findMany({
        where: {
          AND: [
            {
              description: {
                in: categories
              }
            },
            {
              price: {
                gte: persona.priceRange.min * 0.7,
                lte: persona.priceRange.max * 1.3
              }
            }
          ]
        },
        take: 10,
        orderBy: {
          createdAt: 'desc'
        },
        include: {
          owner: {
            select: {
              id: true,
              name: true
            }
          },
          reviews: {
            select: {
              rating: true
            }
          }
        }
      });

      // Calculate average ratings and filter by quality
      const enrichedListings = recommendations.map(listing => {
        const totalRating = listing.reviews.reduce((sum, review) => sum + review.rating, 0);
        const averageRating = listing.reviews.length > 0 ? totalRating / listing.reviews.length : 0;
        
        return {
          id: listing.id,
          title: listing.title,
          description: listing.description,
          price: listing.price,
          location: listing.location,
          images: JSON.parse(listing.images || '[]'),
          ownerId: listing.ownerId,
          ownerName: listing.owner.name,
          averageRating: averageRating,
          reviewCount: listing.reviews.length,
          createdAt: listing.createdAt
        };
      }).filter(listing => listing.averageRating >= 3.5); // Only high-quality listings

      return enrichedListings.slice(0, 5);
    } catch (error) {
      console.error('Error getting personalized recommendations:', error);
      return [];
    }
  }

  /**
   * Get collaborative filtering recommendations ("Users who rented this also rented...")
   * @param userId The user ID to get recommendations for
   * @returns Array of recommended listings based on similar users
   */
  async getCollaborativeRecommendations(userId: string) {
    try {
      // Get user's booking history with detailed information
      const userBookings = await prisma.booking.findMany({
        where: { userId },
        include: {
          listing: {
            select: {
              id: true,
              title: true,
              category: true,
              description: true,
              price: true
            }
          }
        }
      });
      
      if (userBookings.length === 0) {
        return [];
      }
      
      const userListingIds = userBookings.map(booking => booking.listingId);
      const userCategories = [...new Set(userBookings.map(booking => booking.listing.category))].filter(Boolean);
      
      // Find other users who rented similar items (with similarity scoring)
      const similarUsers = await prisma.$queryRaw`
        SELECT 
          b.userId,
          COUNT(b.listingId) as sharedItems,
          COUNT(b.listingId) * 1.0 / (
            SELECT COUNT(*) 
            FROM Booking 
            WHERE userId = b.userId
          ) as similarityScore
        FROM Booking b
        WHERE b.listingId IN (${Prisma.join(userListingIds)})
          AND b.userId != ${userId}
        GROUP BY b.userId
        HAVING COUNT(b.listingId) >= 1
        ORDER BY similarityScore DESC
        LIMIT 20
      `;
      
      if (similarUsers.length === 0) {
        return [];
      }
      
      // Get listings rented by similar users that the current user hasn't rented
      const similarUserIds = similarUsers.map((user: any) => user.userId);
      
      const similarUserBookings = await prisma.booking.findMany({
        where: {
          userId: {
            in: similarUserIds
          },
          listingId: {
            notIn: userListingIds
          }
        },
        include: {
          listing: {
            select: {
              id: true,
              title: true,
              category: true,
              description: true,
              price: true,
              reviews: {
                select: {
                  rating: true
                }
              }
            }
          }
        }
      });
      
      if (similarUserBookings.length === 0) {
        return [];
      }
      
      // Score recommendations based on multiple factors
      const recommendationScores: Record<string, { listing: any; score: number; sources: string[] }> = {};
      
      for (const booking of similarUserBookings) {
        const listingId = booking.listingId;
        
        if (!recommendationScores[listingId]) {
          recommendationScores[listingId] = {
            listing: booking.listing,
            score: 0,
            sources: []
          };
        }
        
        // Find how many similar users rented this item
        const rentingUsers = similarUserBookings.filter(b => b.listingId === listingId).length;
        
        // Base score from user similarity
        const baseScore = rentingUsers * 10;
        
        // Category match bonus
        let categoryBonus = 0;
        if (userCategories.includes(booking.listing.category)) {
          categoryBonus = 20;
          recommendationScores[listingId].sources.push("category_match");
        }
        
        // Popularity bonus
        const popularityBonus = Math.min(rentingUsers * 2, 15);
        
        // Rating bonus
        const avgRating = booking.listing.reviews.length > 0 
          ? booking.listing.reviews.reduce((sum, r) => sum + r.rating, 0) / booking.listing.reviews.length
          : 0;
        const ratingBonus = avgRating * 3;
        
        // Calculate final score
        const finalScore = baseScore + categoryBonus + popularityBonus + ratingBonus;
        
        if (finalScore > recommendationScores[listingId].score) {
          recommendationScores[listingId].score = finalScore;
          if (!recommendationScores[listingId].sources.includes("user_similarity")) {
            recommendationScores[listingId].sources.push("user_similarity");
          }
        }
      }
      
      // Convert to array and sort by score
      const scoredRecommendations = Object.values(recommendationScores)
        .sort((a, b) => b.score - a.score)
        .slice(0, 10); // Top 10 recommendations
      
      // Enrich with additional details
      const enrichedRecommendations = scoredRecommendations.map(rec => {
        const totalRating = rec.listing.reviews.reduce((sum: number, review: any) => sum + review.rating, 0);
        const averageRating = rec.listing.reviews.length > 0 ? totalRating / rec.listing.reviews.length : 0;
        
        return {
          id: rec.listing.id,
          title: rec.listing.title,
          description: rec.listing.description,
          price: rec.listing.price,
          category: rec.listing.category,
          averageRating: averageRating,
          reviewCount: rec.listing.reviews.length,
          recommendationScore: rec.score,
          recommendationSources: rec.sources
        };
      });
      
      return enrichedRecommendations;
    } catch (error) {
      console.error('Error getting collaborative recommendations:', error);
      return [];
    }
  }

  /**
   * Get maintenance recommendations for listed items
   * @param userId The user ID to get maintenance recommendations for
   * @returns Array of maintenance recommendations
   */
  private async getMaintenanceRecommendations(userId: string): Promise<Array<{type: string, message: string, listingId?: string, priority: number}>> {
    const recommendations: Array<{type: string, message: string, listingId?: string, priority: number}> = [];
    
    try {
      // Get user's listed items
      const userListings = await prisma.listing.findMany({
        where: { ownerId: userId },
        select: {
          id: true,
          title: true,
          description: true,
          createdAt: true,
          bookings: {
            select: {
              id: true,
              startDate: true,
              endDate: true,
              status: true
            },
            orderBy: {
              startDate: 'desc'
            }
          }
        }
      });
      
      // For each listing, check if maintenance is needed
      for (const listing of userListings) {
        // Calculate days since last booking
        const lastBooking = listing.bookings.length > 0 ? listing.bookings[0] : null;
        const daysSinceLastBooking = lastBooking 
          ? Math.floor((Date.now() - lastBooking.endDate.getTime()) / (1000 * 60 * 60 * 24))
          : Math.floor((Date.now() - listing.createdAt.getTime()) / (1000 * 60 * 60 * 24));
        
        // Calculate total booking days in the last 30 days
        const recentBookings = listing.bookings.filter(booking => 
          booking.startDate >= new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) &&
          booking.status === 'completed'
        );
        
        const totalBookingDays = recentBookings.reduce((total, booking) => {
          const days = Math.ceil((booking.endDate.getTime() - booking.startDate.getTime()) / (1000 * 60 * 60 * 24));
          return total + days;
        }, 0);
        
        // Recommend maintenance based on usage
        if (totalBookingDays > 10) {
          // High usage - recommend maintenance
          recommendations.push({
            type: "maintenance_recommendation",
            message: `Your "${listing.title}" has been heavily used recently (${totalBookingDays} days in the last 30 days). Consider performing maintenance to keep it in good condition.`,
            listingId: listing.id,
            priority: 9
          });
        } else if (daysSinceLastBooking > 30) {
          // Not used for a while - recommend check-up
          recommendations.push({
            type: "maintenance_recommendation",
            message: `It's been ${daysSinceLastBooking} days since your "${listing.title}" was last rented. Consider checking its condition to ensure it's ready for the next renter.`,
            listingId: listing.id,
            priority: 7
          });
        } else if (listing.bookings.length > 0 && lastBooking.status === 'completed') {
          // Recently used - recommend post-use maintenance
          const daysSinceReturn = Math.floor((Date.now() - lastBooking.endDate.getTime()) / (1000 * 60 * 60 * 24));
          if (daysSinceReturn <= 3) {
            recommendations.push({
              type: "maintenance_recommendation",
              message: `Your "${listing.title}" was recently returned. Now is a good time to perform post-use maintenance if needed.`,
              listingId: listing.id,
              priority: 8
            });
          }
        }
      }
      
      // Sort recommendations by priority
      return recommendations.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error getting maintenance recommendations:', error);
      return recommendations;
    }
  }

  /**
   * Get seasonal listing suggestions for owners
   * @param userId The user ID to get seasonal suggestions for
   * @returns Array of seasonal listing suggestions
   */
  private async getSeasonalListingSuggestions(userId: string): Promise<Array<{type: string, message: string, priority: number}>> {
    const suggestions: Array<{type: string, message: string, priority: number}> = [];
    
    try {
      // Get current month (0-11)
      const currentMonth = new Date().getMonth();
      
      // Enhanced seasonal listing suggestions with category information for better personalization
      const seasonalSuggestions = {
        0: [ // January - New Year
          { item: "New Year's party supplies (decorations, party hats, noisemakers)", categories: ["party", "celebration", "event"] },
          { item: "Winter clothing (sweaters, jackets, scarves)", categories: ["clothing", "fashion", "winter"] },
          { item: "New Year resolution items (fitness equipment, books, planners)", categories: ["sports", "fitness", "education"] }
        ],
        1: [ // February - Valentine's Day
          { item: "Valentine's Day gifts (chocolates, flowers, greeting cards)", categories: ["gift", "romance", "celebration"] },
          { item: "Romantic dinner items (candles, tablecloths, dinnerware)", categories: ["kitchen", "dining", "romance"] },
          { item: "Date night accessories (board games, movie equipment)", categories: ["game", "entertainment", "romance"] }
        ],
        2: [ // March - Spring/Easter
          { item: "Gardening tools (shovels, rakes, watering cans)", categories: ["garden", "outdoor", "tool"] },
          { item: "Spring cleaning supplies (vacuums, mops, cleaning products)", categories: ["cleaning", "home", "utility"] },
          { item: "Easter party items (decorations, baskets, eggs)", categories: ["party", "celebration", "event"] }
        ],
        3: [ // April - Summer preparation
          { item: "Summer sports equipment (beach balls, frisbees, volleyball nets)", categories: ["sports", "outdoor", "recreation"] },
          { item: "Grilling and BBQ equipment (grills, utensils, coolers)", categories: ["kitchen", "outdoor", "cooking"] },
          { item: "Outdoor furniture (patio chairs, tables, umbrellas)", categories: ["furniture", "outdoor", "home"] }
        ],
        4: [ // May - Summer activities
          { item: "Swimming gear (floaties, goggles, swimwear)", categories: ["swimming", "beach", "outdoor"] },
          { item: "Summer party supplies (decorations, serving equipment)", categories: ["party", "celebration", "event"] },
          { item: "Outdoor cooking equipment (portable stoves, griddles)", categories: ["kitchen", "outdoor", "cooking"] }
        ],
        5: [ // June - Mid-year celebrations
          { item: "Independence Day decorations (flags, banners, fireworks)", categories: ["decoration", "celebration", "event"] },
          { item: "Summer vacation rentals (camping gear, travel accessories)", categories: ["travel", "outdoor", "recreation"] },
          { item: "School supplies (backpacks, notebooks, pens)", categories: ["education", "office", "study"] }
        ],
        6: [ // July - Back-to-school
          { item: "School supplies (calculators, laptops, tablets)", categories: ["education", "office", "study"] },
          { item: "Study aids (whiteboards, desk organizers, lamps)", categories: ["education", "study", "technology"] },
          { item: "Back-to-school clothing (uniforms, shoes, bags)", categories: ["clothing", "fashion", "school"] }
        ],
        7: [ // August - Rainy season
          { item: "Rain gear (umbrellas, raincoats, waterproof bags)", categories: ["weather", "outdoor", "utility"] },
          { item: "Indoor entertainment (board games, puzzles, books)", categories: ["game", "entertainment", "home"] },
          { item: "Home improvement tools (leak repair kits, waterproofing supplies)", categories: ["home", "tool", "utility"] }
        ],
        8: [ // September - Harvest season
          { item: "Harvest celebration items (decorations, serving dishes)", categories: ["celebration", "event", "decoration"] },
          { item: "Fall gardening tools (leaf rakes, compost bins)", categories: ["garden", "outdoor", "tool"] },
          { item: "Preservation equipment (dehydrators, canning supplies)", categories: ["kitchen", "food", "utility"] }
        ],
        9: [ // October - Halloween
          { item: "Halloween costumes and accessories", categories: ["costume", "celebration", "fashion"] },
          { item: "Halloween decorations (pumpkins, lights, props)", categories: ["decoration", "celebration", "event"] },
          { item: "Horror movie equipment (projectors, sound systems)", categories: ["entertainment", "media", "technology"] }
        ],
        10: [ // November - Thanksgiving/All Saints
          { item: "Thanksgiving dinner supplies (roasting pans, serving dishes)", categories: ["kitchen", "dining", "cooking"] },
          { item: "Family gathering items (tables, chairs, tablecloths)", categories: ["party", "celebration", "event"] },
          { item: "All Saints' Day decorations (flowers, candles)", categories: ["decoration", "celebration", "event"] }
        ],
        11: [ // December - Christmas
          { item: "Christmas decorations (trees, lights, ornaments)", categories: ["decoration", "celebration", "event"] },
          { item: "Holiday party supplies (decorations, serving equipment)", categories: ["party", "celebration", "event"] },
          { item: "Gift wrapping materials (paper, ribbons, boxes)", categories: ["gift", "party", "utility"] }
        ]
      };
      
      // Get user's rental history to personalize suggestions
      const userBookings = await prisma.booking.findMany({
        where: { userId },
        include: { 
          listing: {
            select: {
              category: true,
              description: true
            }
          }
        }
      });
      
      // Get user's listed items
      const userListings = await prisma.listing.findMany({
        where: { ownerId: userId },
        select: {
          category: true,
          description: true
        }
      });
      
      // Extract categories from user's rental history and listings
      const userCategories = [
        ...userBookings.map(booking => booking.listing.category || booking.listing.description),
        ...userListings.map(listing => listing.category || listing.description)
      ];
      const uniqueCategories = [...new Set(userCategories)].filter(Boolean).map(cat => cat.toLowerCase());
      
      // Get seasonal suggestions for current month
      const monthSuggestions = seasonalSuggestions[currentMonth as keyof typeof seasonalSuggestions] || [];
      
      // Find the most relevant seasonal suggestion based on user preferences
      let bestSeasonalSuggestion = null;
      let highestMatchScore = 0;
      
      // If user has categories, find the best match
      if (uniqueCategories.length > 0) {
        for (const suggestion of monthSuggestions) {
          let matchScore = 0;
          
          // Calculate match score based on category overlap
          for (const category of suggestion.categories) {
            if (uniqueCategories.some(userCat => 
              userCat.includes(category) || 
              category.includes(userCat)
            )) {
              matchScore++;
            }
          }
          
          if (matchScore > highestMatchScore) {
            highestMatchScore = matchScore;
            bestSeasonalSuggestion = suggestion.item;
          }
        }
      }
      
      // If no personalized match found, use the first suggestion
      if (!bestSeasonalSuggestion && monthSuggestions.length > 0) {
        bestSeasonalSuggestion = monthSuggestions[0].item;
      }
      
      // Add personalized seasonal suggestion if available
      if (bestSeasonalSuggestion) {
        suggestions.push({
          type: "seasonal_listing_suggestion",
          message: `Seasonal opportunity: Consider listing ${bestSeasonalSuggestion} for the upcoming season.`,
          priority: 9
        });
      }
      
      // Add category-specific seasonal suggestions
      if (uniqueCategories.length > 0) {
        const userCategory = uniqueCategories[0];
        const categorySuggestions = {
          0: [`${userCategory} for New Year celebrations`],
          1: [`${userCategory} for Valentine's Day gifts`],
          2: [`${userCategory} for spring activities`],
          3: [`${userCategory} for summer use`],
          4: [`${userCategory} for beach/pool activities`],
          5: [`${userCategory} for summer vacations`],
          6: [`${userCategory} for back-to-school`],
          7: [`${userCategory} for indoor use during rains`],
          8: [`${userCategory} for harvest season`],
          9: [`${userCategory} for Halloween`],
          10: [`${userCategory} for family gatherings`],
          11: [`${userCategory} for Christmas gifts`]
        };
        
        const categoryMonthSuggestions = categorySuggestions[currentMonth as keyof typeof categorySuggestions] || [];
        categoryMonthSuggestions.forEach(suggestion => {
          suggestions.push({
            type: "seasonal_listing_suggestion",
            message: `Based on your rental history: Consider listing ${suggestion}.`,
            priority: 8
          });
        });
      }
      
      // Sort suggestions by priority
      return suggestions.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error getting seasonal listing suggestions:', error);
      return suggestions;
    }
  }

  /**
   * Generate detailed analytics dashboard for user interactions
   * @param userId The user ID to generate analytics for (optional, if null generates for all users)
   * @returns Analytics dashboard data
   */
  async generateAnalyticsDashboard(userId?: string) {
    try {
      // Get user activity data
      const userActivity = userId ? await this.getUserActivity(userId) : null;
      
      // Get overall platform metrics
      const platformMetrics = await this.getPlatformMetrics();
      
      // Get AI interaction analytics
      const aiAnalytics = await this.getAIInteractionAnalytics();
      
      // Get user engagement metrics
      const engagementMetrics = await this.getUserEngagementMetrics(userId);
      
      // Get conversion funnel data
      const conversionData = await this.getConversionFunnelData(userId);
      
      // Get sentiment analysis
      const sentimentData = await this.getSentimentAnalysis(userId);
      
      return {
        generatedAt: new Date(),
        userId: userId || 'all',
        platformMetrics,
        aiAnalytics,
        engagementMetrics,
        conversionData,
        sentimentData,
        userActivity
      };
    } catch (error) {
      console.error('Error generating analytics dashboard:', error);
      throw error;
    }
  }

  /**
   * Get overall platform metrics
   * @returns Platform metrics data
   */
  private async getPlatformMetrics() {
    try {
      // Get total users
      const totalUsers = await prisma.user.count();
      
      // Get total listings
      const totalListings = await prisma.listing.count();
      
      // Get total bookings
      const totalBookings = await prisma.booking.count();
      
      // Get total reviews
      const totalReviews = await prisma.review.count();
      
      // Get average rating
      const reviews = await prisma.review.findMany({
        select: { rating: true }
      });
      
      const averageRating = reviews.length > 0 
        ? reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length
        : 0;
      
      // Get recent activity (last 30 days)
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      
      const newUsers = await prisma.user.count({
        where: { createdAt: { gte: thirtyDaysAgo } }
      });
      
      const newListings = await prisma.listing.count({
        where: { createdAt: { gte: thirtyDaysAgo } }
      });
      
      const newBookings = await prisma.booking.count({
        where: { createdAt: { gte: thirtyDaysAgo } }
      });
      
      return {
        totalUsers,
        totalListings,
        totalBookings,
        totalReviews,
        averageRating: averageRating.toFixed(2),
        recentActivity: {
          newUsers,
          newListings,
          newBookings,
          period: "Last 30 days"
        }
      };
    } catch (error) {
      console.error('Error getting platform metrics:', error);
      return {
        totalUsers: 0,
        totalListings: 0,
        totalBookings: 0,
        totalReviews: 0,
        averageRating: "0.00",
        recentActivity: {
          newUsers: 0,
          newListings: 0,
          newBookings: 0,
          period: "Last 30 days"
        }
      };
    }
  }

  /**
   * Get AI interaction analytics
   * @returns AI interaction analytics data
   */
  private async getAIInteractionAnalytics() {
    try {
      // Get total AI interactions
      const totalInteractions = await prisma.aIInteraction.count();
      
      // Get interactions by date (last 30 days)
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      
      const recentInteractions = await prisma.aIInteraction.findMany({
        where: { createdAt: { gte: thirtyDaysAgo } },
        select: { createdAt: true, actionTaken: true }
      });
      
      // Group interactions by date
      const interactionsByDate: Record<string, number> = {};
      recentInteractions.forEach(interaction => {
        const date = interaction.createdAt.toISOString().split('T')[0];
        interactionsByDate[date] = (interactionsByDate[date] || 0) + 1;
      });
      
      // Get action types
      const actionTypes: Record<string, number> = {};
      recentInteractions.forEach(interaction => {
        if (interaction.actionTaken) {
          const actionType = interaction.actionTaken.split(':')[0];
          actionTypes[actionType] = (actionTypes[actionType] || 0) + 1;
        }
      });
      
      // Get feedback data
      const feedbackData = await prisma.aIFeedback.findMany({
        select: { rating: true }
      });
      
      const feedbackStats = {
        total: feedbackData.length,
        averageRating: feedbackData.length > 0 
          ? (feedbackData.reduce((sum, feedback) => sum + feedback.rating, 0) / feedbackData.length).toFixed(2)
          : "0.00",
        ratings: {
          1: feedbackData.filter(f => f.rating === 1).length,
          2: feedbackData.filter(f => f.rating === 2).length,
          3: feedbackData.filter(f => f.rating === 3).length,
          4: feedbackData.filter(f => f.rating === 4).length,
          5: feedbackData.filter(f => f.rating === 5).length
        }
      };
      
      return {
        totalInteractions,
        interactionsByDate,
        actionTypes,
        feedbackStats
      };
    } catch (error) {
      console.error('Error getting AI interaction analytics:', error);
      return {
        totalInteractions: 0,
        interactionsByDate: {},
        actionTypes: {},
        feedbackStats: {
          total: 0,
          averageRating: "0.00",
          ratings: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 }
        }
      };
    }
  }

  /**
   * Prioritize improvements based on impact and frequency
   * @param suggestions Array of improvement suggestions
   * @returns Prioritized improvements
   */
  private prioritizeImprovements(suggestions: Array<{ area: string, suggestion: string, priority: number }>) {
    try {
      // Sort by priority (highest first)
      return suggestions.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error prioritizing improvements:', error);
      return suggestions;
    }
  }

  /**
   * Integrate with user behavior analytics
   * @param userId Optional user ID for personalized analytics
   * @returns User behavior analytics data
   */
  async integrateUserBehaviorAnalytics(userId?: string) {
    try {
      // Get comprehensive user activity data
      const userActivity = userId ? await this.getUserActivity(userId) : null;
      
      // Get platform-wide behavior analytics
      const platformAnalytics = await this.getPlatformBehaviorAnalytics();
      
      // Get user journey analytics
      const journeyAnalytics = await this.getUserJourneyAnalytics(userId);
      
      // Get engagement analytics
      const engagementAnalytics = await this.getEngagementAnalytics(userId);
      
      // Get conversion analytics
      const conversionAnalytics = await this.getConversionAnalytics(userId);
      
      // Combine all analytics data
      const behaviorAnalytics = {
        userActivity,
        platformAnalytics,
        journeyAnalytics,
        engagementAnalytics,
        conversionAnalytics,
        analyzedAt: new Date()
      };
      
      // Store analytics data for future reference
      await prisma.userBehaviorAnalytics.create({
        data: {
          userId,
          analyticsData: JSON.stringify(behaviorAnalytics),
          timestamp: new Date()
        }
      });
      
      return behaviorAnalytics;
    } catch (error) {
      console.error('Error integrating user behavior analytics:', error);
      throw error;
    }
  }

  /**
   * Get platform-wide behavior analytics
   * @returns Platform behavior analytics data
   */
  private async getPlatformBehaviorAnalytics() {
    try {
      // Get user activity statistics
      const totalUsers = await prisma.user.count();
      const activeUsers = await prisma.user.count({
        where: {
          bookings: {
            some: {
              createdAt: {
                gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
              }
            }
          }
        }
      });
      
      // Get listing statistics
      const totalListings = await prisma.listing.count();
      const activeListings = await prisma.listing.count({
        where: {
          bookings: {
            some: {
              createdAt: {
                gte: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) // Last 90 days
              }
            }
          }
        }
      });
      
      // Get booking statistics
      const totalBookings = await prisma.booking.count();
      const recentBookings = await prisma.booking.count({
        where: {
          createdAt: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
          }
        }
      });
      
      // Get review statistics
      const totalReviews = await prisma.review.count();
      const recentReviews = await prisma.review.count({
        where: {
          createdAt: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
          }
        }
      });
      
      // Calculate average ratings
      const reviews = await prisma.review.findMany({
        select: { rating: true }
      });
      
      const averageRating = reviews.length > 0 
        ? reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length
        : 0;
      
      return {
        userStatistics: {
          totalUsers,
          activeUsers,
          activeUserPercentage: totalUsers > 0 ? parseFloat(((activeUsers / totalUsers) * 100).toFixed(2)) : 0
        },
        listingStatistics: {
          totalListings,
          activeListings,
          activeListingPercentage: totalListings > 0 ? parseFloat(((activeListings / totalListings) * 100).toFixed(2)) : 0
        },
        bookingStatistics: {
          totalBookings,
          recentBookings,
          recentBookingPercentage: totalBookings > 0 ? parseFloat(((recentBookings / totalBookings) * 100).toFixed(2)) : 0
        },
        reviewStatistics: {
          totalReviews,
          recentReviews,
          averageRating: parseFloat(averageRating.toFixed(2))
        }
      };
    } catch (error) {
      console.error('Error getting platform behavior analytics:', error);
      return {
        userStatistics: { totalUsers: 0, activeUsers: 0, activeUserPercentage: 0 },
        listingStatistics: { totalListings: 0, activeListings: 0, activeListingPercentage: 0 },
        bookingStatistics: { totalBookings: 0, recentBookings: 0, recentBookingPercentage: 0 },
        reviewStatistics: { totalReviews: 0, recentReviews: 0, averageRating: 0 }
      };
    }
  }

  /**
   * Get user journey analytics
   * @param userId Optional user ID
   * @returns User journey analytics data
   */
  private async getUserJourneyAnalytics(userId?: string) {
    try {
      const whereClause = userId ? { userId } : {};
      
      // Get user interactions with the platform
      const interactions = await prisma.aIInteraction.findMany({
        where: whereClause,
        orderBy: { createdAt: 'asc' }
      });
      
      // Get user bookings
      const bookings = await prisma.booking.findMany({
        where: whereClause,
        include: { listing: true },
        orderBy: { createdAt: 'asc' }
      });
      
      // Get user listings
      const listings = userId ? await prisma.listing.findMany({
        where: { ownerId: userId },
        orderBy: { createdAt: 'asc' }
      }) : [];
      
      // Get user reviews
      const reviews = await prisma.review.findMany({
        where: whereClause,
        include: { listing: true },
        orderBy: { createdAt: 'asc' }
      });
      
      // Calculate journey metrics
      const firstInteraction = interactions.length > 0 ? interactions[0].createdAt : null;
      const firstBooking = bookings.length > 0 ? bookings[0].createdAt : null;
      const firstListing = listings.length > 0 ? listings[0].createdAt : null;
      const firstReview = reviews.length > 0 ? reviews[0].createdAt : null;
      
      // Calculate time to first actions
      const timeToFirstBooking = firstInteraction && firstBooking 
        ? Math.ceil((firstBooking.getTime() - firstInteraction.getTime()) / (1000 * 60 * 60 * 24))
        : null;
      
      const timeToFirstListing = firstInteraction && firstListing 
        ? Math.ceil((firstListing.getTime() - firstInteraction.getTime()) / (1000 * 60 * 60 * 24))
        : null;
      
      // Identify user type based on activities
      let userType = 'visitor';
      if (bookings.length > 0 && listings.length > 0) {
        userType = 'power_user';
      } else if (bookings.length > 0) {
        userType = 'renter';
      } else if (listings.length > 0) {
        userType = 'owner';
      }
      
      return {
        userType,
        journeyMilestones: {
          firstInteraction,
          firstBooking,
          firstListing,
          firstReview
        },
        timeToActions: {
          timeToFirstBooking,
          timeToFirstListing
        },
        activityCounts: {
          interactions: interactions.length,
          bookings: bookings.length,
          listings: listings.length,
          reviews: reviews.length
        }
      };
    } catch (error) {
      console.error('Error getting user journey analytics:', error);
      return {
        userType: 'unknown',
        journeyMilestones: {
          firstInteraction: null,
          firstBooking: null,
          firstListing: null,
          firstReview: null
        },
        timeToActions: {
          timeToFirstBooking: null,
          timeToFirstListing: null
        },
        activityCounts: {
          interactions: 0,
          bookings: 0,
          listings: 0,
          reviews: 0
        }
      };
    }
  }

  /**
   * Get engagement analytics
   * @param userId Optional user ID
   * @returns Engagement analytics data
   */
  private async getEngagementAnalytics(userId?: string) {
    try {
      const whereClause = userId ? { userId } : {};
      
      // Get user interactions in the last 30 days
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      
      const recentInteractions = await prisma.aIInteraction.findMany({
        where: {
          ...whereClause,
          createdAt: { gte: thirtyDaysAgo }
        }
      });
      
      // Get user bookings in the last 30 days
      const recentBookings = await prisma.booking.findMany({
        where: {
          ...whereClause,
          createdAt: { gte: thirtyDaysAgo }
        }
      });
      
      // Get user listings in the last 30 days
      const recentListings = userId ? await prisma.listing.findMany({
        where: {
          ownerId: userId,
          createdAt: { gte: thirtyDaysAgo }
        }
      }) : [];
      
      // Calculate engagement score (simplified)
      const interactionScore = recentInteractions.length;
      const bookingScore = recentBookings.length * 2;
      const listingScore = recentListings.length * 3;
      
      const totalScore = interactionScore + bookingScore + listingScore;
      const engagementLevel = totalScore > 20 ? 'high' : totalScore > 10 ? 'medium' : 'low';
      
      // Calculate daily activity pattern
      const dailyActivity: Record<string, number> = {};
      
      [...recentInteractions, ...recentBookings, ...recentListings].forEach(activity => {
        const day = activity.createdAt.toISOString().split('T')[0];
        dailyActivity[day] = (dailyActivity[day] || 0) + 1;
      });
      
      return {
        engagementLevel,
        engagementScore: totalScore,
        activityBreakdown: {
          interactions: interactionScore,
          bookings: bookingScore,
          listings: listingScore
        },
        dailyActivity,
        period: "Last 30 days"
      };
    } catch (error) {
      console.error('Error getting engagement analytics:', error);
      return {
        engagementLevel: 'unknown',
        engagementScore: 0,
        activityBreakdown: {
          interactions: 0,
          bookings: 0,
          listings: 0
        },
        dailyActivity: {},
        period: "Last 30 days"
      };
    }
  }

  /**
   * Get conversion analytics
   * @param userId Optional user ID
   * @returns Conversion analytics data
   */
  private async getConversionAnalytics(userId?: string) {
    try {
      const whereClause = userId ? { userId } : {};
      
      // Get all interactions that led to actions
      const interactions = await prisma.aIInteraction.findMany({
        where: whereClause,
        select: { actionTaken: true, createdAt: true }
      });
      
      // Count interactions by action type
      const actionCounts: Record<string, number> = {};
      let totalConversions = 0;
      
      interactions.forEach(interaction => {
        if (interaction.actionTaken) {
          const actionType = interaction.actionTaken.split(':')[0];
          actionCounts[actionType] = (actionCounts[actionType] || 0) + 1;
          
          // Count conversions (booking, listing, payment actions)
          if (['booking', 'listing', 'payment'].includes(actionType)) {
            totalConversions++;
          }
        }
      });
      
      // Calculate conversion rate
      const totalInteractions = interactions.length;
      const conversionRate = totalInteractions > 0 
        ? parseFloat(((totalConversions / totalInteractions) * 100).toFixed(2))
        : 0;
      
      return {
        totalInteractions,
        totalConversions,
        conversionRate,
        actionBreakdown: actionCounts
      };
    } catch (error) {
      console.error('Error getting conversion analytics:', error);
      return {
        totalInteractions: 0,
        totalConversions: 0,
        conversionRate: 0,
        actionBreakdown: {}
      };
    }
  }

  /**
   * Enhance booking management assistance
   * @param userId User ID
   * @param context Current AI context
   * @returns Booking management assistance data
   */
  async enhanceBookingManagement(userId: string, context: AIContext) {
    try {
      // Get user's bookings
      const userBookings = await prisma.booking.findMany({
        where: { userId },
        include: { 
          listing: {
            include: {
              owner: {
                select: {
                  id: true,
                  name: true
                }
              }
            }
          }
        },
        orderBy: { createdAt: 'desc' }
      });
      
      // Categorize bookings
      const upcomingBookings = userBookings.filter(booking => 
        booking.startDate > new Date() && booking.status === 'confirmed'
      );
      
      const currentBookings = userBookings.filter(booking => 
        booking.startDate <= new Date() && booking.endDate >= new Date() && booking.status === 'confirmed'
      );
      
      const pastBookings = userBookings.filter(booking => 
        booking.endDate < new Date() || booking.status !== 'confirmed'
      );
      
      // Generate booking management suggestions
      const suggestions = this.generateBookingManagementSuggestions(
        upcomingBookings, 
        currentBookings, 
        pastBookings,
        context
      );
      
      // Get booking statistics
      const bookingStats = {
        total: userBookings.length,
        upcoming: upcomingBookings.length,
        current: currentBookings.length,
        past: pastBookings.length
      };
      
      return {
        bookingStats,
        upcomingBookings: upcomingBookings.slice(0, 5), // Limit to 5 upcoming bookings
        currentBookings: currentBookings.slice(0, 5), // Limit to 5 current bookings
        recentPastBookings: pastBookings.slice(0, 5), // Limit to 5 recent past bookings
        suggestions,
        lastUpdated: new Date()
      };
    } catch (error) {
      console.error('Error enhancing booking management:', error);
      throw error;
    }
  }

  /**
   * Generate booking management suggestions
   * @param upcomingBookings Upcoming bookings
   * @param currentBookings Current bookings
   * @param pastBookings Past bookings
   * @param context Current AI context
   * @returns Booking management suggestions
   */
  private generateBookingManagementSuggestions(
    upcomingBookings: any[], 
    currentBookings: any[], 
    pastBookings: any[],
    context: AIContext
  ) {
    try {
      const suggestions: string[] = [];
      
      // Suggestions for upcoming bookings
      if (upcomingBookings.length > 0) {
        const nextBooking = upcomingBookings[0];
        const daysUntilBooking = Math.ceil(
          (nextBooking.startDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)
        );
        
        if (daysUntilBooking <= 3) {
          suggestions.push(`Your rental "${nextBooking.listing.title}" starts in ${daysUntilBooking} day(s). Contact ${nextBooking.listing.owner.name} to confirm pickup details.`);
        } else if (daysUntilBooking <= 7) {
          suggestions.push(`Your rental "${nextBooking.listing.title}" starts next week. Plan accordingly!`);
        }
        
        // If user has multiple upcoming bookings
        if (upcomingBookings.length > 3) {
          suggestions.push(`You have ${upcomingBookings.length} upcoming bookings. Consider creating a rental calendar to keep track of them.`);
        }
      }
      
      // Suggestions for current bookings
      if (currentBookings.length > 0) {
        const currentBooking = currentBookings[0];
        const daysRemaining = Math.ceil(
          (currentBooking.endDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)
        );
        
        if (daysRemaining <= 2) {
          suggestions.push(`Your rental "${currentBooking.listing.title}" is due in ${daysRemaining} day(s). Don't forget to return it on time!`);
        }
        
        // If user has multiple current bookings
        if (currentBookings.length > 1) {
          suggestions.push(`You currently have ${currentBookings.length} active rentals. Keep track of their return dates.`);
        }
      }
      
      // Suggestions for past bookings
      if (pastBookings.length > 0) {
        const recentBooking = pastBookings[0];
        
        // Suggest leaving a review if not already done
        if (!recentBooking.reviewId) {
          suggestions.push(`You recently rented "${recentBooking.listing.title}". Consider leaving a review to help other renters.`);
        }
        
        // Suggest rebooking popular items
        const popularItems = pastBookings
          .filter(booking => booking.status === 'completed')
          .map(booking => booking.listing)
          .filter((listing, index, self) => 
            self.findIndex(l => l.id === listing.id) === index
          )
          .slice(0, 3);
        
        if (popularItems.length > 0) {
          suggestions.push(`You might want to rent similar items: ${popularItems.map(item => item.title).join(', ')}`);
        }
      }
      
      // General suggestions based on booking history
      const totalCompletedBookings = pastBookings.filter(b => b.status === 'completed').length;
      
      if (totalCompletedBookings > 10) {
        suggestions.push("You're a frequent renter! Consider becoming an owner to list your own items and earn extra income.");
      } else if (totalCompletedBookings > 5) {
        suggestions.push("You've completed several rentals. Keep building your rental history!");
      }
      
      // Suggestions based on user context
      if (context.userPreferences?.categories?.length) {
        suggestions.push(`Find more rentals in your favorite categories: ${context.userPreferences.categories.slice(0, 3).join(', ')}`);
      }
      
      return suggestions;
    } catch (error) {
      console.error('Error generating booking management suggestions:', error);
      return [];
    }
  }

  /**
   * Add payment assistance features
   * @param userId User ID
   * @param context Current AI context
   * @returns Payment assistance data
   */
  async addPaymentAssistance(userId: string, context: AIContext) {
    try {
      // Get user's payment history
      const userTransactions = await prisma.transaction.findMany({
        where: { userId },
        include: { 
          booking: {
            include: {
              listing: {
                select: {
                  id: true,
                  title: true,
                  price: true
                }
              }
            }
          }
        },
        orderBy: { createdAt: 'desc' }
      });
      
      // Get user's upcoming payments
      const upcomingPayments = await prisma.booking.findMany({
        where: { 
          userId,
          status: 'confirmed',
          startDate: { gte: new Date() }
        },
        include: { 
          listing: {
            select: {
              id: true,
              title: true,
              price: true
            }
          }
        },
        orderBy: { startDate: 'asc' }
      });
      
      // Calculate payment statistics
      const totalSpent = userTransactions.reduce((sum, transaction) => sum + transaction.amount, 0);
      const averageSpent = userTransactions.length > 0 ? totalSpent / userTransactions.length : 0;
      
      // Get payment methods
      const paymentMethods = [...new Set(userTransactions.map(t => t.paymentMethod))].filter(Boolean);
      
      // Generate payment assistance suggestions
      const suggestions = this.generatePaymentAssistanceSuggestions(
        userTransactions, 
        upcomingPayments, 
        paymentMethods,
        context
      );
      
      // Get payment security information
      const securityInfo = this.getPaymentSecurityInfo();
      
      return {
        paymentStats: {
          totalTransactions: userTransactions.length,
          totalSpent: parseFloat(totalSpent.toFixed(2)),
          averageSpent: parseFloat(averageSpent.toFixed(2)),
          paymentMethods
        },
        recentTransactions: userTransactions.slice(0, 5), // Limit to 5 recent transactions
        upcomingPayments: upcomingPayments.slice(0, 5), // Limit to 5 upcoming payments
        suggestions,
        securityInfo,
        lastUpdated: new Date()
      };
    } catch (error) {
      console.error('Error adding payment assistance:', error);
      throw error;
    }
  }

  /**
   * Generate payment assistance suggestions
   * @param transactions User's transaction history
   * @param upcomingPayments Upcoming payments
   * @param paymentMethods Available payment methods
   * @param context Current AI context
   * @returns Payment assistance suggestions
   */
  private generatePaymentAssistanceSuggestions(
    transactions: any[], 
    upcomingPayments: any[], 
    paymentMethods: string[],
    context: AIContext
  ) {
    try {
      const suggestions: string[] = [];
      
      // Suggestions for upcoming payments
      if (upcomingPayments.length > 0) {
        const nextPayment = upcomingPayments[0];
        const daysUntilPayment = Math.ceil(
          (nextPayment.startDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)
        );
        
        if (daysUntilPayment <= 3) {
          suggestions.push(`Payment of ₱${nextPayment.totalPrice} for "${nextPayment.listing.title}" is due in ${daysUntilPayment} day(s). Ensure your payment method is ready.`);
        } else if (daysUntilPayment <= 7) {
          suggestions.push(`Payment of ₱${nextPayment.totalPrice} for "${nextPayment.listing.title}" is due next week. Plan your budget accordingly.`);
        }
        
        // If user has multiple upcoming payments
        if (upcomingPayments.length > 3) {
          const totalUpcomingAmount = upcomingPayments.reduce((sum, payment) => sum + payment.totalPrice, 0);
          suggestions.push(`You have ${upcomingPayments.length} upcoming payments totaling ₱${totalUpcomingAmount.toFixed(2)}. Consider setting up payment reminders.`);
        }
      }
      
      // Suggestions based on transaction history
      if (transactions.length > 0) {
        const recentTransactions = transactions.slice(0, 5);
        const totalRecentSpent = recentTransactions.reduce((sum, t) => sum + t.amount, 0);
        
        if (totalRecentSpent > 5000) {
          suggestions.push(`You've spent ₱${totalRecentSpent.toFixed(2)} recently on rentals. Consider setting a monthly rental budget.`);
        }
        
        // Suggest payment method optimization
        if (paymentMethods.length > 1) {
          suggestions.push(`You've used ${paymentMethods.length} different payment methods. Consider using your preferred method for faster checkouts.`);
        } else if (paymentMethods.length === 1) {
          suggestions.push(`You primarily use ${paymentMethods[0]} for payments. Consider adding a backup payment method for reliability.`);
        }
      }
      
      // General payment tips
      suggestions.push("All payments are securely processed and held until after your rental period ends.");
      suggestions.push("You can view your complete payment history in your account settings.");
      
      // Suggestions based on user context
      if (context.userPreferences?.priceRange) {
        suggestions.push(`Based on your preferences, rentals in the ₱${context.userPreferences.priceRange.min}-₱${context.userPreferences.priceRange.max} range might fit your budget.`);
      }
      
      return suggestions;
    } catch (error) {
      console.error('Error generating payment assistance suggestions:', error);
      return [];
    }
  }

  /**
   * Get payment security information
   * @returns Payment security information
   */
  private getPaymentSecurityInfo() {
    return {
      encryption: "All payments are encrypted using industry-standard SSL/TLS protocols",
      protection: "Payments are held securely until after your rental period ends",
      refundPolicy: "Refunds are processed according to our cancellation policy",
      disputeResolution: "Disputes are handled through our mediation process",
      dataProtection: "Your payment information is never shared with third parties"
    };
  }

  /**
   * Implement review and rating system assistance
   * @param userId User ID
   * @param context Current AI context
   * @returns Review and rating assistance data
   */
  async implementReviewAssistance(userId: string, context: AIContext) {
    try {
      // Get user's reviews
      const userReviews = await prisma.review.findMany({
        where: { userId },
        include: { 
          listing: {
            select: {
              id: true,
              title: true
            }
          }
        },
        orderBy: { createdAt: 'desc' }
      });
      
      // Get listings that need reviews
      const completedBookingsWithoutReviews = await prisma.booking.findMany({
        where: { 
          userId,
          status: 'completed',
          review: null
        },
        include: { 
          listing: {
            select: {
              id: true,
              title: true
            }
          }
        },
        orderBy: { endDate: 'desc' }
      });
      
      // Get user's average rating
      const averageRating = userReviews.length > 0 
        ? userReviews.reduce((sum, review) => sum + review.rating, 0) / userReviews.length
        : 0;
      
      // Generate review assistance suggestions
      const suggestions = this.generateReviewAssistanceSuggestions(
        userReviews, 
        completedBookingsWithoutReviews,
        context
      );
      
      // Get review guidelines
      const reviewGuidelines = this.getReviewGuidelines();
      
      return {
        reviewStats: {
          totalReviews: userReviews.length,
          averageRating: parseFloat(averageRating.toFixed(2)),
          ratingsDistribution: this.getRatingsDistribution(userReviews)
        },
        recentReviews: userReviews.slice(0, 5), // Limit to 5 recent reviews
        listingsNeedingReviews: completedBookingsWithoutReviews.slice(0, 5), // Limit to 5 listings needing reviews
        suggestions,
        reviewGuidelines,
        lastUpdated: new Date()
      };
    } catch (error) {
      console.error('Error implementing review assistance:', error);
      throw error;
    }
  }

  /**
   * Generate review assistance suggestions
   * @param reviews User's reviews
   * @param listingsNeedingReviews Listings that need reviews
   * @param context Current AI context
   * @returns Review assistance suggestions
   */
  private generateReviewAssistanceSuggestions(
    reviews: any[], 
    listingsNeedingReviews: any[], 
    context: AIContext
  ) {
    try {
      const suggestions: string[] = [];
      
      // Suggestions for listings needing reviews
      if (listingsNeedingReviews.length > 0) {
        const listing = listingsNeedingReviews[0];
        suggestions.push(`You recently rented "${listing.listing.title}" and haven't left a review yet. Your feedback helps other renters!`);
        
        // If user has multiple listings needing reviews
        if (listingsNeedingReviews.length > 3) {
          suggestions.push(`You have ${listingsNeedingReviews.length} rentals that need reviews. Consider leaving feedback for all of them.`);
        }
      }
      
      // Suggestions based on review history
      if (reviews.length > 0) {
        const recentReviews = reviews.slice(0, 3);
        
        // Check for review patterns
        const avgRecentRating = recentReviews.reduce((sum, review) => sum + review.rating, 0) / recentReviews.length;
        
        if (avgRecentRating < 3) {
          suggestions.push("Your recent reviews have been critical. Consider highlighting positive aspects when appropriate.");
        } else if (avgRecentRating > 4) {
          suggestions.push("Your recent reviews have been very positive. Keep up the constructive feedback!");
        }
        
        // Suggest reviewing patterns
        if (reviews.length > 10) {
          suggestions.push("You're an active reviewer! Your feedback helps build a trustworthy community.");
        }
      } else {
        suggestions.push("Leave your first review to help build a trustworthy community!");
      }
      
      // General review tips
      suggestions.push("Be specific and constructive in your reviews to help others make informed decisions.");
      suggestions.push("Include details about the item's condition, accuracy of description, and owner's communication.");
      
      // Suggestions based on user context
      if (context.userPreferences?.categories?.length) {
        suggestions.push(`Share your experience with rentals in categories like: ${context.userPreferences.categories.slice(0, 3).join(', ')}`);
      }
      
      return suggestions;
    } catch (error) {
      console.error('Error generating review assistance suggestions:', error);
      return [];
    }
  }

  /**
   * Get ratings distribution
   * @param reviews Array of reviews
   * @returns Ratings distribution
   */
  private getRatingsDistribution(reviews: any[]) {
    const distribution = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
    
    reviews.forEach(review => {
      if (review.rating >= 1 && review.rating <= 5) {
        distribution[review.rating as keyof typeof distribution]++;
      }
    });
    
    return distribution;
  }

  /**
   * Get review guidelines
   * @returns Review guidelines
   */
  private getReviewGuidelines() {
    return {
      helpfulReviews: [
        "Be honest and specific about your experience",
        "Mention both positive and negative aspects",
        "Include details about the item's condition and accuracy of description",
        "Comment on the owner's communication and reliability",
        "Avoid personal attacks or offensive language"
      ],
      ratingCriteria: {
        5: "Excellent - Exceeded expectations in all aspects",
        4: "Good - Met expectations with minor issues",
        3: "Average - Met basic expectations",
        2: "Poor - Significant issues that affected the experience",
        1: "Terrible - Major problems or misleading information"
      },
      communityGuidelines: [
        "Reviews must be based on actual rental experiences",
        "No fake or biased reviews",
        "Respect privacy - don't share personal information",
        "Constructive criticism is encouraged",
        "Report inappropriate reviews to support"
      ]
    };
  }

  /**
   * Get predictive navigation suggestions based on user activity
   * @param userId The user ID to get suggestions for
   * @returns Array of navigation suggestions
   */
  async getPredictiveNavigationSuggestions(userId: string) {
    try {
      // Get user's recent activity
      const userActivity = await this.getUserActivity(userId);
      
      // Analyze activity patterns
      const activityPatterns = userActivity.map(activity => activity.type);
      const activityFrequency = activityPatterns.reduce((acc, type) => {
        acc[type] = (acc[type] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);
      
      // Prioritize suggestions based on activity frequency
      const suggestions = Object.keys(activityFrequency).map(type => ({
        type,
        priority: activityFrequency[type]
      })).sort((a, b) => b.priority - a.priority);
      
      // Generate navigation suggestions
      const navigationSuggestions = suggestions.map(suggestion => {
        switch (suggestion.type) {
          case 'booking':
            return { type: 'booking', message: 'Explore more listings to book', priority: suggestion.priority };
          case 'listing':
            return { type: 'listing', message: 'Create a new listing', priority: suggestion.priority };
          case 'review':
            return { type: 'review', message: 'Write a review for your recent booking', priority: suggestion.priority };
          case 'wishlist':
            return { type: 'wishlist', message: 'Add items to your wishlist', priority: suggestion.priority };
          case 'payment':
            return { type: 'payment', message: 'Manage your payment methods', priority: suggestion.priority };
          default:
            return { type: 'unknown', message: 'Explore more features', priority: suggestion.priority };
        }
      });
      
      return navigationSuggestions;
    } catch (error) {
      console.error('Error getting predictive navigation suggestions:', error);
      return [];
    }
  }
  /**
   * Get user engagement metrics
   * @param userId The user ID to get metrics for (optional)
   * @returns User engagement metrics
   */
  private async getUserEngagementMetrics(userId?: string) {
    try {
      // Get user activity data
      let userActivityData = null;
      if (userId) {
        userActivityData = await this.getUserActivity(userId);
      }
      
      // Get engagement levels
      const engagementLevels = {
        high: 0,
        medium: 0,
        low: 0
      };
      
      if (userId && userActivityData) {
        const totalActivities = 
          userActivityData.recentBookings.length +
          userActivityData.wishlistItems.length +
          userActivityData.unreadMessages +
          userActivityData.recentReviews.length +
          userActivityData.recentListings.length;
        
        if (totalActivities > 20) {
          engagementLevels.high = 1;
        } else if (totalActivities > 10) {
          engagementLevels.medium = 1;
        } else {
          engagementLevels.low = 1;
        }
      } else if (!userId) {
        // For all users, get engagement distribution
        // This would require more complex queries in a real implementation
        engagementLevels.high = 0;
        engagementLevels.medium = 0;
        engagementLevels.low = 0;
      }
      
      // Get retention data (simplified)
      const retentionData = {
        daily: 0,
        weekly: 0,
        monthly: 0
      };
      
      return {
        engagementLevels,
        retentionData,
        userActivity: userActivityData
      };
    } catch (error) {
      console.error('Error getting user engagement metrics:', error);
      return {
        engagementLevels: { high: 0, medium: 0, low: 0 },
        retentionData: { daily: 0, weekly: 0, monthly: 0 },
        userActivity: null
      };
    }
  }

  /**
   * Get conversion funnel data
   * @param userId The user ID to get data for (optional)
   * @returns Conversion funnel data
   */
  private async getConversionFunnelData(userId?: string) {
    try {
      // Get funnel stages
      const funnelStages = {
        visitors: 0,
        viewers: 0,
        wishlists: 0,
        bookings: 0
      };
      
      if (userId) {
        // For specific user
        const userActivity = await this.getUserActivity(userId);
        funnelStages.visitors = 1; // The user themselves
        funnelStages.viewers = userActivity.recentBookings.length > 0 ? 1 : 0;
        funnelStages.wishlists = userActivity.wishlistItems.length > 0 ? 1 : 0;
        funnelStages.bookings = userActivity.recentBookings.length > 0 ? 1 : 0;
      } else {
        // For all users (simplified)
        funnelStages.visitors = await prisma.user.count();
        funnelStages.viewers = await prisma.booking.count();
        funnelStages.wishlists = await prisma.wishlist.count();
        funnelStages.bookings = await prisma.booking.count({
          where: { status: 'completed' }
        });
      }
      
      // Calculate conversion rates
      const conversionRates = {
        visitorToViewer: funnelStages.visitors > 0 
          ? ((funnelStages.viewers / funnelStages.visitors) * 100).toFixed(2)
          : "0.00",
        viewerToWishlist: funnelStages.viewers > 0 
          ? ((funnelStages.wishlists / funnelStages.viewers) * 100).toFixed(2)
          : "0.00",
        wishlistToBooking: funnelStages.wishlists > 0 
          ? ((funnelStages.bookings / funnelStages.wishlists) * 100).toFixed(2)
          : "0.00"
      };
      
      return {
        funnelStages,
        conversionRates
      };
    } catch (error) {
      console.error('Error getting conversion funnel data:', error);
      return {
        funnelStages: { visitors: 0, viewers: 0, wishlists: 0, bookings: 0 },
        conversionRates: { visitorToViewer: "0.00", viewerToWishlist: "0.00", wishlistToBooking: "0.00" }
      };
    }
  }

  /**
   * Get sentiment analysis data
   * @param userId The user ID to get data for (optional)
   * @returns Sentiment analysis data
   */
  private async getSentimentAnalysis(userId?: string) {
    try {
      // Get sentiment data from AI interactions
      const whereClause = userId ? { userId } : {};
      
      const interactions = await prisma.aIInteraction.findMany({
        where: whereClause,
        select: { userInput: true }
      });
      
      // Simple sentiment analysis based on keywords
      const sentimentCounts = {
        positive: 0,
        negative: 0,
        neutral: 0
      };
      
      // Define sentiment keywords
      const positiveKeywords = [
        'great', 'awesome', 'excellent', 'wonderful', 'fantastic', 'amazing', 'love', 'like',
        'perfect', 'good', 'nice', 'thank', 'thanks', 'happy', 'pleased', 'satisfied', 'cool'
      ];
      
      const negativeKeywords = [
        'bad', 'terrible', 'awful', 'horrible', 'hate', 'dislike', 'worst', 'angry',
        'frustrated', 'annoyed', 'upset', 'disappointed', 'confused', 'difficult'
      ];
      
      interactions.forEach(interaction => {
        const lowerInput = interaction.userInput.toLowerCase();
        const positiveMatches = positiveKeywords.filter(keyword => lowerInput.includes(keyword));
        const negativeMatches = negativeKeywords.filter(keyword => lowerInput.includes(keyword));
        
        if (positiveMatches.length > negativeMatches.length) {
          sentimentCounts.positive++;
        } else if (negativeMatches.length > positiveMatches.length) {
          sentimentCounts.negative++;
        } else {
          sentimentCounts.neutral++;
        }
      });
      
      const totalInteractions = interactions.length;
      
      return {
        sentimentCounts,
        sentimentPercentages: {
          positive: totalInteractions > 0 
            ? ((sentimentCounts.positive / totalInteractions) * 100).toFixed(2)
            : "0.00",
          negative: totalInteractions > 0 
            ? ((sentimentCounts.negative / totalInteractions) * 100).toFixed(2)
            : "0.00",
          neutral: totalInteractions > 0 
            ? ((sentimentCounts.neutral / totalInteractions) * 100).toFixed(2)
            : "0.00"
        },
        totalInteractions
      };
    } catch (error) {
      console.error('Error getting sentiment analysis:', error);
      return {
        sentimentCounts: { positive: 0, negative: 0, neutral: 0 },
        sentimentPercentages: { positive: "0.00", negative: "0.00", neutral: "0.00" },
        totalInteractions: 0
      };
    }
  }

  /**
   * Implement automated A/B testing for response strategies
   * @param testConfig Configuration for the A/B test
   * @returns Test results and recommendations
   */
  async implementABTesting(testConfig: {
    testName: string,
    variants: Array<{ name: string, strategy: string }>,
    durationDays: number,
    metrics: string[]
  }) {
    try {
      // Create or update A/B test record
      const testRecord = await prisma.aBTest.upsert({
        where: { testName: testConfig.testName },
        update: {
          variants: JSON.stringify(testConfig.variants),
          durationDays: testConfig.durationDays,
          metrics: JSON.stringify(testConfig.metrics),
          updatedAt: new Date()
        },
        create: {
          testName: testConfig.testName,
          variants: JSON.stringify(testConfig.variants),
          durationDays: testConfig.durationDays,
          metrics: JSON.stringify(testConfig.metrics),
          startDate: new Date(),
          status: 'active'
        }
      });
      
      // Get test results
      const testResults = await this.getABTestResults(testConfig.testName);
      
      // Analyze results and generate recommendations
      const recommendations = this.analyzeABTestResults(testResults);
      
      return {
        testId: testRecord.id,
        testName: testConfig.testName,
        status: testRecord.status,
        results: testResults,
        recommendations
      };
    } catch (error) {
      console.error('Error implementing A/B testing:', error);
      throw error;
    }
  }

  /**
   * Get A/B test results
   * @param testName The name of the test to get results for
   * @returns Test results
   */
  private async getABTestResults(testName: string) {
    try {
      // Get test record
      const testRecord = await prisma.aBTest.findUnique({
        where: { testName }
      });
      
      if (!testRecord) {
        return null;
      }
      
      // Get variant data
      const variants = JSON.parse(testRecord.variants || '[]');
      
      // Get interaction data for each variant
      const variantResults: Array<{ 
        variantName: string, 
        interactionCount: number, 
        avgRating: number, 
        conversionRate: number 
      }> = [];
      
      for (const variant of variants) {
        // Get interactions for this variant
        const interactions = await prisma.aIInteraction.findMany({
          where: {
            actionTaken: {
              contains: `variant:${variant.name}`
            },
            createdAt: {
              gte: testRecord.startDate,
              lte: new Date(testRecord.startDate.getTime() + testRecord.durationDays * 24 * 60 * 60 * 1000)
            }
          }
        });
        
        // Get feedback for these interactions
        const interactionIds = interactions.map(i => i.id);
        const feedback = await prisma.aIFeedback.findMany({
          where: {
            messageId: { in: interactionIds }
          }
        });
        
        // Calculate metrics
        const interactionCount = interactions.length;
        const avgRating = feedback.length > 0 
          ? feedback.reduce((sum, f) => sum + f.rating, 0) / feedback.length
          : 0;
        
        // Calculate conversion rate (simplified)
        const conversions = interactions.filter(i => 
          i.actionTaken && i.actionTaken.includes('conversion')
        ).length;
        
        const conversionRate = interactionCount > 0 
          ? (conversions / interactionCount) * 100
          : 0;
        
        variantResults.push({
          variantName: variant.name,
          interactionCount,
          avgRating: parseFloat(avgRating.toFixed(2)),
          conversionRate: parseFloat(conversionRate.toFixed(2))
        });
      }
      
      return {
        testName,
        startDate: testRecord.startDate,
        durationDays: testRecord.durationDays,
        variants: variantResults,
        status: testRecord.status
      };
    } catch (error) {
      console.error('Error getting A/B test results:', error);
      return null;
    }
  }

  /**
   * Analyze A/B test results and generate recommendations
   * @param testResults The test results to analyze
   * @returns Analysis and recommendations
   */
  private analyzeABTestResults(testResults: any) {
    if (!testResults || !testResults.variants || testResults.variants.length === 0) {
      return {
        recommendation: "Insufficient data for analysis",
        confidence: 0
      };
    }
    
    // Find the best performing variant based on multiple metrics
    const variants = testResults.variants;
    
    // Sort by average rating (primary metric)
    const sortedByRating = [...variants].sort((a, b) => b.avgRating - a.avgRating);
    const bestByRating = sortedByRating[0];
    
    // Sort by conversion rate (secondary metric)
    const sortedByConversion = [...variants].sort((a, b) => b.conversionRate - a.conversionRate);
    const bestByConversion = sortedByConversion[0];
    
    // Calculate statistical significance (simplified)
    const avgRatingDiff = Math.abs(bestByRating.avgRating - sortedByRating[sortedByRating.length - 1].avgRating);
    const conversionDiff = Math.abs(bestByConversion.conversionRate - sortedByConversion[sortedByConversion.length - 1].conversionRate);
    
    const ratingConfidence = avgRatingDiff > 0.5 ? 0.9 : avgRatingDiff > 0.2 ? 0.7 : 0.5;
    const conversionConfidence = conversionDiff > 10 ? 0.9 : conversionDiff > 5 ? 0.7 : 0.5;
    
    const overallConfidence = (ratingConfidence + conversionConfidence) / 2;
    
    // Generate recommendation
    let recommendation = "";
    if (bestByRating.avgRating > bestByConversion.avgRating) {
      recommendation = `Recommend using variant "${bestByRating.variantName}" which achieved the highest user satisfaction rating of ${bestByRating.avgRating}.`;
    } else {
      recommendation = `Recommend using variant "${bestByConversion.variantName}" which achieved the highest conversion rate of ${bestByConversion.conversionRate}%.`;
    }
    
    // If both metrics favor the same variant, stronger recommendation
    if (bestByRating.variantName === bestByConversion.variantName) {
      recommendation = `Strongly recommend using variant "${bestByRating.variantName}" which performed best on both user satisfaction (${bestByRating.avgRating} rating) and conversion rate (${bestByConversion.conversionRate}%).`;
    }
    
    return {
      recommendation,
      confidence: parseFloat(overallConfidence.toFixed(2)),
      metrics: {
        bestByRating: {
          variant: bestByRating.variantName,
          rating: bestByRating.avgRating
        },
        bestByConversion: {
          variant: bestByConversion.variantName,
          rate: bestByConversion.conversionRate
        }
      }
    };
  }

  /**
   * Implement automated A/B testing for response strategies
   * @param testConfig Configuration for the A/B test
   * @returns Test results and recommendations
   */
  async implementABTesting(testConfig: {
    testName: string,
    variants: Array<{ name: string, strategy: string }>,
    durationDays: number,
    metrics: string[]
  }) {
    try {
      // Create or update A/B test record
      const testRecord = await prisma.aBTest.upsert({
        where: { testName: testConfig.testName },
        update: {
          variants: JSON.stringify(testConfig.variants),
          durationDays: testConfig.durationDays,
          metrics: JSON.stringify(testConfig.metrics),
          updatedAt: new Date()
        },
        create: {
          testName: testConfig.testName,
          variants: JSON.stringify(testConfig.variants),
          durationDays: testConfig.durationDays,
          metrics: JSON.stringify(testConfig.metrics),
          startDate: new Date(),
          status: 'active'
        }
      });
      
      // Get test results
      const testResults = await this.getABTestResults(testConfig.testName);
      
      // Analyze results and generate recommendations
      const recommendations = this.analyzeABTestResults(testResults);
      
      return {
        testId: testRecord.id,
        testName: testConfig.testName,
        status: testRecord.status,
        results: testResults,
        recommendations
      };
    } catch (error) {
      console.error('Error implementing A/B testing:', error);
      throw error;
    }
  }

  /**
   * Get A/B test results
   * @param testName The name of the test to get results for
   * @returns Test results
   */
  private async getABTestResults(testName: string) {
    try {
      // Get test record
      const testRecord = await prisma.aBTest.findUnique({
        where: { testName }
      });
      
      if (!testRecord) {
        return null;
      }
      
      // Get variant data
      const variants = JSON.parse(testRecord.variants || '[]');
      
      // Get interaction data for each variant
      const variantResults: Array<{ 
        variantName: string, 
        interactionCount: number, 
        avgRating: number, 
        conversionRate: number 
      }> = [];
      
      for (const variant of variants) {
        // Get interactions for this variant
        const interactions = await prisma.aIInteraction.findMany({
          where: {
            actionTaken: {
              contains: `variant:${variant.name}`
            },
            createdAt: {
              gte: testRecord.startDate,
              lte: new Date(testRecord.startDate.getTime() + testRecord.durationDays * 24 * 60 * 60 * 1000)
            }
          }
        });
        
        // Get feedback for these interactions
        const interactionIds = interactions.map(i => i.id);
        const feedback = await prisma.aIFeedback.findMany({
          where: {
            messageId: { in: interactionIds }
          }
        });
        
        // Calculate metrics
        const interactionCount = interactions.length;
        const avgRating = feedback.length > 0 
          ? feedback.reduce((sum, f) => sum + f.rating, 0) / feedback.length
          : 0;
        
        // Calculate conversion rate (simplified)
        const conversions = interactions.filter(i => 
          i.actionTaken && i.actionTaken.includes('conversion')
        ).length;
        
        const conversionRate = interactionCount > 0 
          ? (conversions / interactionCount) * 100
          : 0;
        
        variantResults.push({
          variantName: variant.name,
          interactionCount,
          avgRating: parseFloat(avgRating.toFixed(2)),
          conversionRate: parseFloat(conversionRate.toFixed(2))
        });
      }
      
      return {
        testName,
        startDate: testRecord.startDate,
        durationDays: testRecord.durationDays,
        variants: variantResults,
        status: testRecord.status
      };
    } catch (error) {
      console.error('Error getting A/B test results:', error);
      return null;
    }
  }

  /**
   * Analyze A/B test results and generate recommendations
   * @param testResults The test results to analyze
   * @returns Analysis and recommendations
   */
  private analyzeABTestResults(testResults: any) {
    if (!testResults || !testResults.variants || testResults.variants.length === 0) {
      return {
        recommendation: "Insufficient data for analysis",
        confidence: 0
      };
    }
    
    // Find the best performing variant based on multiple metrics
    const variants = testResults.variants;
    
    // Sort by average rating (primary metric)
    const sortedByRating = [...variants].sort((a, b) => b.avgRating - a.avgRating);
    const bestByRating = sortedByRating[0];
    
    // Sort by conversion rate (secondary metric)
    const sortedByConversion = [...variants].sort((a, b) => b.conversionRate - a.conversionRate);
    const bestByConversion = sortedByConversion[0];
    
    // Calculate statistical significance (simplified)
    const avgRatingDiff = Math.abs(bestByRating.avgRating - sortedByRating[sortedByRating.length - 1].avgRating);
    const conversionDiff = Math.abs(bestByConversion.conversionRate - sortedByConversion[sortedByConversion.length - 1].conversionRate);
    
    const ratingConfidence = avgRatingDiff > 0.5 ? 0.9 : avgRatingDiff > 0.2 ? 0.7 : 0.5;
    const conversionConfidence = conversionDiff > 10 ? 0.9 : conversionDiff > 5 ? 0.7 : 0.5;
    
    const overallConfidence = (ratingConfidence + conversionConfidence) / 2;
    
    // Generate recommendation
    let recommendation = "";
    if (bestByRating.avgRating > bestByConversion.avgRating) {
      recommendation = `Recommend using variant "${bestByRating.variantName}" which achieved the highest user satisfaction rating of ${bestByRating.avgRating}.`;
    } else {
      recommendation = `Recommend using variant "${bestByConversion.variantName}" which achieved the highest conversion rate of ${bestByConversion.conversionRate}%.`;
    }
    
    // If both metrics favor the same variant, stronger recommendation
    if (bestByRating.variantName === bestByConversion.variantName) {
      recommendation = `Strongly recommend using variant "${bestByRating.variantName}" which performed best on both user satisfaction (${bestByRating.avgRating} rating) and conversion rate (${bestByConversion.conversionRate}%).`;
    }
    
    return {
      recommendation,
      confidence: parseFloat(overallConfidence.toFixed(2)),
      metrics: {
        bestByRating: {
          variant: bestByRating.variantName,
          rating: bestByRating.avgRating
        },
        bestByConversion: {
          variant: bestByConversion.variantName,
          rate: bestByConversion.conversionRate
        }
      }
    };
  }

  /**
   * Implement continuous learning from user feedback
   * @param feedbackData User feedback data
   * @returns Learning results and updates
   */
  async implementContinuousLearning(feedbackData?: { userId?: string, rating?: number, comment?: string }) {
    try {
      // If specific feedback data is provided, log it
      if (feedbackData) {
        await prisma.aIFeedback.create({
          data: {
            userId: feedbackData.userId,
            rating: feedbackData.rating || 0,
            comment: feedbackData.comment,
            messageId: `manual_feedback_${Date.now()}`,
            createdAt: new Date()
          }
        });
      }
      
      // Get all feedback data
      const allFeedback = await prisma.aIFeedback.findMany({
        include: { user: true }
      });
      
      // Analyze feedback patterns
      const feedbackAnalysis = this.analyzeFeedbackPatterns(allFeedback);
      
      // Update AI behavior based on feedback
      const behaviorUpdates = await this.updateAIBehaviorFromFeedback(feedbackAnalysis);
      
      // Generate learning report
      const learningReport = {
        totalFeedback: allFeedback.length,
        averageRating: feedbackAnalysis.averageRating,
        commonIssues: feedbackAnalysis.commonIssues,
        behaviorUpdates,
        lastUpdated: new Date()
      };
      
      return learningReport;
    } catch (error) {
      console.error('Error implementing continuous learning:', error);
      throw error;
    }
  }

  /**
   * Analyze feedback patterns
   * @param feedbackData Array of feedback data
   * @returns Analysis results
   */
  private analyzeFeedbackPatterns(feedbackData: any[]) {
    try {
      // Calculate average rating
      const totalRating = feedbackData.reduce((sum, feedback) => sum + feedback.rating, 0);
      const averageRating = feedbackData.length > 0 ? totalRating / feedbackData.length : 0;
      
      // Identify common issues from comments
      const comments = feedbackData
        .filter(f => f.comment)
        .map(f => f.comment.toLowerCase());
      
      // Define common issue keywords
      const issueKeywords = {
        'navigation': ['navigate', 'find', 'lost', 'confused', 'where', 'path'],
        'response_quality': ['wrong', 'incorrect', 'bad', 'poor', 'unclear', 'confusing'],
        'speed': ['slow', 'fast', 'quick', 'delay'],
        'accuracy': ['accurate', 'inaccurate', 'wrong', 'correct', 'mistake'],
        'helpfulness': ['helpful', 'unhelpful', 'useful', 'useless', 'assist', 'support']
      };
      
      // Count issue occurrences
      const commonIssues: Record<string, number> = {};
      
      for (const [category, keywords] of Object.entries(issueKeywords)) {
        let count = 0;
        for (const comment of comments) {
          for (const keyword of keywords) {
            if (comment.includes(keyword)) {
              count++;
              break;
            }
          }
        }
        commonIssues[category] = count;
      }
      
      // Get rating distribution
      const ratingDistribution = {
        1: feedbackData.filter(f => f.rating === 1).length,
        2: feedbackData.filter(f => f.rating === 2).length,
        3: feedbackData.filter(f => f.rating === 3).length,
        4: feedbackData.filter(f => f.rating === 4).length,
        5: feedbackData.filter(f => f.rating === 5).length
      };
      
      return {
        averageRating: parseFloat(averageRating.toFixed(2)),
        totalFeedback: feedbackData.length,
        commonIssues,
        ratingDistribution
      };
    } catch (error) {
      console.error('Error analyzing feedback patterns:', error);
      return {
        averageRating: 0,
        totalFeedback: 0,
        commonIssues: {},
        ratingDistribution: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 }
      };
    }
  }

  /**
   * Update AI behavior based on feedback analysis
   * @param feedbackAnalysis Analysis results
   * @returns Behavior updates
   */
  private async updateAIBehaviorFromFeedback(feedbackAnalysis: any) {
    try {
      const updates: string[] = [];
      
      // If navigation issues are common, improve navigation assistance
      if (feedbackAnalysis.commonIssues.navigation > feedbackAnalysis.totalFeedback * 0.1) {
        updates.push("Enhanced navigation assistance and pathfinding capabilities");
      }
      
      // If response quality issues are common, improve response generation
      if (feedbackAnalysis.commonIssues.response_quality > feedbackAnalysis.totalFeedback * 0.15) {
        updates.push("Improved response accuracy and clarity");
      }
      
      // If speed issues are common, optimize processing
      if (feedbackAnalysis.commonIssues.speed > feedbackAnalysis.totalFeedback * 0.1) {
        updates.push("Optimized response generation speed");
      }
      
      // If accuracy issues are common, improve information retrieval
      if (feedbackAnalysis.commonIssues.accuracy > feedbackAnalysis.totalFeedback * 0.1) {
        updates.push("Enhanced information retrieval and fact-checking");
      }
      
      // If average rating is low, implement comprehensive improvements
      if (feedbackAnalysis.averageRating < 3) {
        updates.push("Comprehensive behavior review and improvement implementation");
      }
      
      // If average rating is high, reinforce successful patterns
      if (feedbackAnalysis.averageRating >= 4) {
        updates.push("Reinforced successful response patterns");
      }
      
      // Log behavior updates
      if (updates.length > 0) {
        console.log('AI Behavior Updates:', updates);
      }
      
      return updates;
    } catch (error) {
      console.error('Error updating AI behavior from feedback:', error);
      return [];
    }
  }

  /**
   * Implement reinforcement learning capabilities
   * @param userId Optional user ID for personalized learning
   * @returns Reinforcement learning results
   */
  async implementReinforcementLearning(userId?: string) {
    try {
      // Get interaction history for learning
      const whereClause = userId ? { userId } : {};
      const interactions = await prisma.aIInteraction.findMany({
        where: whereClause,
        include: { user: true },
        orderBy: { createdAt: 'desc' },
        take: 1000 // Limit to last 1000 interactions for performance
      });
      
      // Get feedback data
      const interactionIds = interactions.map(i => i.id);
      const feedback = await prisma.aIFeedback.findMany({
        where: { messageId: { in: interactionIds } }
      });
      
      // Create feedback lookup map
      const feedbackMap = new Map(feedback.map(f => [f.messageId, f]));
      
      // Analyze successful interactions (rating >= 4)
      const successfulInteractions = interactions.filter(interaction => {
        const interactionFeedback = feedbackMap.get(interaction.id);
        return interactionFeedback && interactionFeedback.rating >= 4;
      });
      
      // Analyze unsuccessful interactions (rating <= 2)
      const unsuccessfulInteractions = interactions.filter(interaction => {
        const interactionFeedback = feedbackMap.get(interaction.id);
        return interactionFeedback && interactionFeedback.rating <= 2;
      });
      
      // Extract patterns from successful interactions
      const successPatterns = this.extractPatternsFromInteractions(successfulInteractions, 'success');
      
      // Extract patterns from unsuccessful interactions
      const failurePatterns = this.extractPatternsFromInteractions(unsuccessfulInteractions, 'failure');
      
      // Generate reinforcement learning model updates
      const modelUpdates = this.generateReinforcementUpdates(successPatterns, failurePatterns);
      
      // Apply model updates
      const appliedUpdates = await this.applyReinforcementUpdates(modelUpdates);
      
      // Generate learning report
      const learningReport = {
        totalInteractions: interactions.length,
        successfulInteractions: successfulInteractions.length,
        unsuccessfulInteractions: unsuccessfulInteractions.length,
        successRate: interactions.length > 0 
          ? parseFloat(((successfulInteractions.length / interactions.length) * 100).toFixed(2))
          : 0,
        extractedSuccessPatterns: successPatterns.length,
        extractedFailurePatterns: failurePatterns.length,
        modelUpdates: appliedUpdates,
        lastUpdated: new Date()
      };
      
      return learningReport;
    } catch (error) {
      console.error('Error implementing reinforcement learning:', error);
      throw error;
    }
  }

  /**
   * Extract patterns from interactions
   * @param interactions Array of interactions
   * @param type Type of interactions (success or failure)
   * @returns Extracted patterns
   */
  private extractPatternsFromInteractions(interactions: any[], type: 'success' | 'failure') {
    try {
      const patterns: Array<{ 
        intent: string, 
        entities: string[], 
        responseStyle: string, 
        actionTaken: string,
        frequency: number 
      }> = [];
      
      // Group interactions by intent
      const intentGroups: Record<string, any[]> = {};
      
      interactions.forEach(interaction => {
        // Classify intent from user input
        const intent = this.classifyIntentFromInput(interaction.userInput);
        
        if (!intentGroups[intent]) {
          intentGroups[intent] = [];
        }
        intentGroups[intent].push(interaction);
      });
      
      // Process each intent group
      for (const [intent, group] of Object.entries(intentGroups)) {
        const entities = this.extractEntitiesFromGroup(group);
        const responseStyle = this.determineResponseStyle(group);
        const actionTaken = this.determineActionTaken(group);
        const frequency = group.length;
        
        patterns.push({
          intent,
          entities,
          responseStyle,
          actionTaken,
          frequency
        });
      }
      
      return patterns;
    } catch (error) {
      console.error('Error extracting patterns from interactions:', error);
      return [];
    }
  }

  /**
   * Generate reinforcement learning model updates
   * @param successPatterns Patterns from successful interactions
   * @param failurePatterns Patterns from unsuccessful interactions
   * @returns Model updates
   */
  private generateReinforcementUpdates(successPatterns: any[], failurePatterns: any[]) {
    try {
      const updates: string[] = [];
      
      // In a real implementation, this would:
      // 1. Compare success and failure patterns
      // 2. Identify differences and similarities
      // 3. Generate updates to improve the model
      
      // For now, we'll just log the patterns
      if (successPatterns.length > 0) {
        console.log('Success Patterns:', successPatterns);
      }
      
      if (failurePatterns.length > 0) {
        console.log('Failure Patterns:', failurePatterns);
      }
      
      return updates;
    } catch (error) {
      console.error('Error generating reinforcement updates:', error);
      return [];
    }
  }

  /**
   * Apply reinforcement updates to the model
   * @param updates Array of updates to apply
   * @returns Applied updates
   */
  private async applyReinforcementUpdates(updates: string[]) {
    try {
      // In a real implementation, this would:
      // 1. Update the AI model weights based on reinforcement learning
      // 2. Adjust response templates and strategies
      // 3. Modify intent classification parameters
      // 4. Update entity extraction rules
      
      // For now, we'll just log the updates
      if (updates.length > 0) {
        console.log('Reinforcement Learning Updates:', updates);
      }
      
      // Create a reinforcement learning record
      await prisma.reinforcementLearningRecord.create({
        data: {
          updates: JSON.stringify(updates),
          timestamp: new Date()
        }
      });
      
      return updates;
    } catch (error) {
      console.error('Error applying reinforcement updates:', error);
      return [];
    }
  }

  /**
   * Implement active learning to identify improvement areas
   * @param userId Optional user ID for personalized learning
   * @returns Active learning results and improvement suggestions
   */
  async implementActiveLearning(userId?: string) {
    try {
      // Get interaction history for analysis
      const whereClause = userId ? { userId } : {};
      const interactions = await prisma.aIInteraction.findMany({
        where: whereClause,
        include: { user: true },
        orderBy: { createdAt: 'desc' },
        take: 1000 // Limit to last 1000 interactions for performance
      });
      
      // Get feedback data
      const interactionIds = interactions.map(i => i.id);
      const feedback = await prisma.aIFeedback.findMany({
        where: { messageId: { in: interactionIds } }
      });
      
      // Create feedback lookup map
      const feedbackMap = new Map(feedback.map(f => [f.messageId, f]));
      
      // Identify areas for improvement
      const improvementAreas = this.identifyImprovementAreas(interactions, feedbackMap);
      
      // Generate specific improvement suggestions
      const improvementSuggestions = this.generateImprovementSuggestions(interactions, feedbackMap, improvementAreas);
      
      // Prioritize improvements based on impact
      const prioritizedImprovements = this.prioritizeImprovements(improvementSuggestions);
      
      // Generate active learning report
      const learningReport = {
        totalInteractions: interactions.length,
        totalFeedback: feedback.length,
        improvementAreas,
        improvementSuggestions: prioritizedImprovements,
        lastAnalyzed: new Date()
      };
      
      // Log the active learning results
      await prisma.activeLearningRecord.create({
        data: {
          userId,
          results: JSON.stringify(learningReport),
          timestamp: new Date()
        }
      });
      
      return learningReport;
    } catch (error) {
      console.error('Error implementing active learning:', error);
      throw error;
    }
  }

  /**
   * Identify areas for improvement from interactions and feedback
   * @param interactions Array of interactions
   * @param feedbackMap Map of feedback by message ID
   * @returns Identified improvement areas
   */
  private identifyImprovementAreas(interactions: any[], feedbackMap: Map<string, any>) {
    try {
      const areas: Record<string, number> = {};
      
      // Analyze interactions for common issues
      interactions.forEach(interaction => {
        const interactionFeedback = feedbackMap.get(interaction.id);
        
        // Check for low-rated interactions
        if (interactionFeedback && interactionFeedback.rating <= 2) {
          // Analyze the user input for common patterns
          const lowerInput = interaction.userInput.toLowerCase();
          
          // Identify issue categories
          if (lowerInput.includes('find') || lowerInput.includes('search') || lowerInput.includes('where')) {
            areas['search_improvement'] = (areas['search_improvement'] || 0) + 1;
          }
          
          if (lowerInput.includes('book') || lowerInput.includes('rent') || lowerInput.includes('reserve')) {
            areas['booking_improvement'] = (areas['booking_improvement'] || 0) + 1;
          }
          
          if (lowerInput.includes('list') || lowerInput.includes('sell') || lowerInput.includes('offer')) {
            areas['listing_improvement'] = (areas['listing_improvement'] || 0) + 1;
          }
          
          if (lowerInput.includes('help') || lowerInput.includes('support') || lowerInput.includes('problem')) {
            areas['support_improvement'] = (areas['support_improvement'] || 0) + 1;
          }
          
          if (lowerInput.includes('pay') || lowerInput.includes('payment') || lowerInput.includes('price')) {
            areas['payment_improvement'] = (areas['payment_improvement'] || 0) + 1;
          }
        }
        
        // Check for repeated interactions (user asking same question multiple times)
        const similarInteractions = interactions.filter(i => 
          i.userInput.toLowerCase().includes(interaction.userInput.toLowerCase().substring(0, 10)) &&
          i.id !== interaction.id
        );
        
        if (similarInteractions.length > 2) {
          areas['repeated_queries'] = (areas['repeated_queries'] || 0) + 1;
        }
        
        // Check for escalation to human support
        if (interaction.actionTaken && interaction.actionTaken.includes('escalate_to_human')) {
          areas['human_escalation'] = (areas['human_escalation'] || 0) + 1;
        }
      });
      
      return areas;
    } catch (error) {
      console.error('Error identifying improvement areas:', error);
      return {};
    }
  }

  /**
   * Generate specific improvement suggestions
   * @param interactions Array of interactions
   * @param feedbackMap Map of feedback by message ID
   * @param improvementAreas Identified improvement areas
   * @returns Improvement suggestions
   */
  private generateImprovementSuggestions(interactions: any[], feedbackMap: Map<string, any>, improvementAreas: Record<string, number>) {
    try {
      const suggestions: Array<{ area: string, suggestion: string, priority: number }> = [];
      
      // Generate suggestions based on identified areas
      for (const [area, count] of Object.entries(improvementAreas)) {
        let suggestion = "";
        let priority = 0;
        
        switch (area) {
          case 'search_improvement':
            suggestion = "Enhance search functionality with better natural language processing and fuzzy matching";
            priority = count > 10 ? 9 : count > 5 ? 7 : 5;
            break;
          case 'booking_improvement':
            suggestion = "Improve booking workflow with better date selection and availability checking";
            priority = count > 10 ? 9 : count > 5 ? 7 : 5;
            break;
          case 'listing_improvement':
            suggestion = "Enhance listing creation process with better guidance and category suggestions";
            priority = count > 10 ? 9 : count > 5 ? 7 : 5;
            break;
          case 'support_improvement':
            suggestion = "Expand support knowledge base with more comprehensive help articles";
            priority = count > 10 ? 9 : count > 5 ? 7 : 5;
            break;
          case 'payment_improvement':
            suggestion = "Clarify payment processes and provide more detailed pricing information";
            priority = count > 10 ? 9 : count > 5 ? 7 : 5;
            break;
          case 'repeated_queries':
            suggestion = "Implement better context retention to avoid repetitive questions";
            priority = count > 10 ? 9 : count > 5 ? 7 : 5;
            break;
          case 'human_escalation':
            suggestion = "Improve intent recognition to reduce unnecessary human escalations";
            priority = count > 10 ? 9 : count > 5 ? 7 : 5;
            break;
          default:
            suggestion = `Address issues in ${area} area`;
            priority = count > 10 ? 7 : count > 5 ? 5 : 3;
        }
        
        suggestions.push({
          area,
          suggestion,
          priority
        });
      }
      
      return suggestions;
    } catch (error) {
      console.error('Error generating improvement suggestions:', error);
      return [];
    }
  }

  /**
   * Prioritize improvements based on impact and frequency
   * @param suggestions Array of improvement suggestions
   * @returns Prioritized improvements
   */
  private prioritizeImprovements(suggestions: Array<{ area: string, suggestion: string, priority: number }>) {
    try {
      // Sort by priority (highest first)
      return suggestions.sort((a, b) => b.priority - a.priority);
    } catch (error) {
      console.error('Error prioritizing improvements:', error);
      return suggestions;
    }
  }

  /**
   * Get predictive navigation suggestions based on user activity
          frequency
        });
      }
      
      return patterns;
    } catch (error) {
      console.error('Error extracting patterns from interactions:', error);
      return [];
    }
  }

  /**
   * Classify intent from user input
   * @param userInput User input text
   * @returns Intent classification
   */
  private classifyIntentFromInput(userInput: string) {
    // Implement intent classification logic here
    return 'default';
  }

  /**
   * Extract entities from a group of interactions
   * @param group Array of interactions
   * @returns Array of entities
   */
  private extractEntitiesFromGroup(group: any[]) {
    // Implement entity extraction logic here
    return [];
  }

  /**
   * Determine response style from a group of interactions
   * @param group Array of interactions
   * @returns Response style
   */
  private determineResponseStyle(group: any[]) {
    // Implement response style determination logic here
    return 'default';
  }

  /**
   * Determine action taken from a group of interactions
   * @param group Array of interactions
   * @returns Action taken
   */
  private determineActionTaken(group: any[]) {
    // Implement action taken determination logic here
    return 'default';
  }

  /**
   * Generate reinforcement learning model updates
   * @param successPatterns Extracted success patterns
   * @param failurePatterns Extracted failure patterns
   * @returns Model updates
   */
  private generateReinforcementUpdates(successPatterns: any[], failurePatterns: any[]) {
    // Implement model update generation logic here
    return [];
  }

  /**
   * Apply reinforcement learning model updates
   * @param updates Model updates
   * @returns Applied updates
   */
  private async applyReinforcementUpdates(updates: any[]) {
    // Implement model update application logic here
    return [];
  }

  /**
   * Get predictive navigation suggestions based on user activity
   * @param context Current user context
   * @returns Array of predictive navigation suggestions
   */
  private async getPredictiveNavigation(context: AIContext): Promise<Array<{path: string, label: string, confidence: number}>> {
    const predictions: Array<{path: string, label: string, confidence: number}> = [];
    
    if (!context.userId) {
      return predictions;
    }
    
    try {
      // Get user's recent activity
      const userActivity = await this.getUserActivity(context.userId);
      
      // Predict based on recent bookings
      if (userActivity.recentBookings.length > 0) {
        predictions.push({
          path: "/my-bookings",
          label: "My Bookings",
          confidence: 0.8
        });
        
        // If user has recent bookings, suggest checking status
        predictions.push({
          path: "/booking-status",
          label: "Check Booking Status",
          confidence: 0.7
        });
      }
      
      // Predict based on wishlist items
      if (userActivity.wishlistItems.length > 0) {
        predictions.push({
          path: "/wishlist",
          label: "My Wishlist",
          confidence: 0.75
        });
      }
      
      // Predict based on listed items
      if (userActivity.recentListings.length > 0) {
        predictions.push({
          path: "/my-listings",
          label: "My Listings",
          confidence: 0.8
        });
        
        // Suggest creating new listings if user is active
        predictions.push({
          path: "/list-item",
          label: "List New Item",
          confidence: 0.6
        });
      }
      
      // Predict based on unread messages
      if (userActivity.unreadMessages > 0) {
        predictions.push({
          path: "/inbox",
          label: "Messages",
          confidence: 0.9
        });
      }
      
      // Predict based on time of day
      const currentHour = new Date().getHours();
      if (currentHour >= 18 && currentHour <= 24) {
        // Evening time - suggest listing items
        predictions.push({
          path: "/list-item",
          label: "List an Item",
          confidence: 0.65
        });
      } else if (currentHour >= 9 && currentHour <= 17) {
        // Business hours - suggest browsing
        predictions.push({
          path: "/browse",
          label: "Browse Rentals",
          confidence: 0.65
        });
      }
      
      // Sort by confidence and return top 3
      return predictions
        .sort((a, b) => b.confidence - a.confidence)
        .slice(0, 3);
    } catch (error) {
      console.error('Error getting predictive navigation:', error);
      return predictions;
    }
  }

  /**
   * Get breadcrumb navigation path for current page
   * @param context Current user context
   * @returns Array of breadcrumb navigation items
   */
  private getBreadcrumbNavigation(context: AIContext): Array<{path: string, label: string}> {
    const breadcrumbs: Array<{path: string, label: string}> = [];
    
    if (!context.currentSession?.currentPage) {
      return breadcrumbs;
    }
    
    const currentPage = context.currentSession.currentPage;
    
    // Generate breadcrumbs based on current page
    if (currentPage.includes('/listing/')) {
      breadcrumbs.push(
        { path: "/", label: "Home" },
        { path: "/browse", label: "Browse" },
        { path: currentPage, label: "Item Details" }
      );
    } else if (currentPage.includes('/my-bookings')) {
      breadcrumbs.push(
        { path: "/", label: "Home" },
        { path: "/my-bookings", label: "My Bookings" }
      );
    } else if (currentPage.includes('/my-listings')) {
      breadcrumbs.push(
        { path: "/", label: "Home" },
        { path: "/my-listings", label: "My Listings" }
      );
    } else if (currentPage.includes('/list-item')) {
      breadcrumbs.push(
        { path: "/", label: "Home" },
        { path: "/my-listings", label: "My Listings" },
        { path: "/list-item", label: "Create Listing" }
      );
    } else if (currentPage.includes('/profile')) {
      breadcrumbs.push(
        { path: "/", label: "Home" },
        { path: "/profile", label: "Profile" }
      );
    } else if (currentPage.includes('/inbox')) {
      breadcrumbs.push(
        { path: "/", label: "Home" },
        { path: "/inbox", label: "Messages" }
      );
    } else if (currentPage.includes('/wishlist')) {
      breadcrumbs.push(
        { path: "/", label: "Home" },
        { path: "/wishlist", label: "Wishlist" }
      );
    } else if (currentPage.includes('/browse')) {
      breadcrumbs.push(
        { path: "/", label: "Home" },
        { path: "/browse", label: "Browse Rentals" }
      );
    }
    
    return breadcrumbs;
  }

  /**
   * Log AI interactions for self-improvement
   */
  private async logInteraction(userInput: string, response: AIResponse, context: AIContext) {
    try {
      await renFeedbackService.logInteraction({
        userId: context.userId,
        userInput: userInput,
        aiResponse: response.text,
        actionTaken: response.action ? `${response.action.type}:${JSON.stringify(response.action.payload)}` : undefined,
        timestamp: new Date()
      });
    } catch (error) {
      console.error('Error logging interaction:', error);
    }
  }

  /**
   * Implement preference learning through implicit feedback
   * Analyzes user interactions to infer preferences without explicit input
   * @param userId The user ID to analyze
   * @returns Inferred user preferences
   */
  async learnPreferencesFromImplicitFeedback(userId: string) {
    try {
      // Get comprehensive user activity data
      const userActivity = await this.getUserActivity(userId);
      
      // Get user's interaction history with the AI
      const aiInteractions = await prisma.aIInteraction.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
        take: 100 // Limit to last 100 interactions for performance
      });
      
      // Analyze viewing patterns
      const viewedListings = await this.analyzeViewingPatterns(userId);
      
      // Analyze search patterns
      const searchPatterns = await this.analyzeSearchPatterns(userId, aiInteractions);
      
      // Analyze booking patterns
      const bookingPatterns = await this.analyzeBookingPatterns(userId, userActivity);
      
      // Analyze wishlist patterns
      const wishlistPatterns = await this.analyzeWishlistPatterns(userId, userActivity);
      
      // Analyze messaging patterns
      const messagingPatterns = await this.analyzeMessagingPatterns(userId);
      
      // Combine all patterns to infer preferences
      const inferredPreferences = this.combineImplicitFeedback(
        viewedListings,
        searchPatterns,
        bookingPatterns,
        wishlistPatterns,
        messagingPatterns
      );
      
      // Update user preferences in database
      await this.updateUserPreferencesFromImplicitFeedback(userId, inferredPreferences);
      
      return inferredPreferences;
    } catch (error) {
      console.error('Error learning preferences from implicit feedback:', error);
      return null;
    }
  }

  /**
   * Analyze viewing patterns to infer user interests
   * @param userId The user ID to analyze
   * @returns Viewing pattern analysis
   */
  private async analyzeViewingPatterns(userId: string) {
    try {
      // Get user's viewed listings (would need to be tracked in a view history table)
      // For now, we'll simulate this with booking and wishlist data
      const userBookings = await prisma.booking.findMany({
        where: { userId },
        include: { listing: true },
        orderBy: { createdAt: 'desc' },
        take: 50
      });
      
      const userWishlist = await prisma.wishlist.findMany({
        where: { userId },
        include: { listing: true },
        orderBy: { createdAt: 'desc' },
        take: 50
      });
      
      // Combine viewed items (bookings + wishlist as proxy for views)
      const viewedItems = [...userBookings.map(b => b.listing), ...userWishlist.map(w => w.listing)];
      
      // Extract categories and features
      const categories: Record<string, number> = {};
      const priceRanges: number[] = [];
      const locations: Record<string, number> = {};
      
      viewedItems.forEach(item => {
        // Count category occurrences
        if (item.category) {
          categories[item.category] = (categories[item.category] || 0) + 1;
        }
        
        // Collect price data
        priceRanges.push(item.price);
        
        // Count location occurrences
        if (item.location) {
          locations[item.location] = (locations[item.location] || 0) + 1;
        }
      });
      
      // Sort categories by frequency
      const sortedCategories = Object.entries(categories)
        .sort(([,a], [,b]) => b - a)
        .map(([category]) => category);
      
      // Sort locations by frequency
      const sortedLocations = Object.entries(locations)
        .sort(([,a], [,b]) => b - a)
        .map(([location]) => location);
      
      // Calculate price range statistics
      const minPrice = priceRanges.length > 0 ? Math.min(...priceRanges) : 0;
      const maxPrice = priceRanges.length > 0 ? Math.max(...priceRanges) : 0;
      const avgPrice = priceRanges.length > 0 ? priceRanges.reduce((sum, price) => sum + price, 0) / priceRanges.length : 0;
      
      return {
        preferredCategories: sortedCategories,
        preferredPriceRange: { min: minPrice, max: maxPrice, avg: avgPrice },
        preferredLocations: sortedLocations,
        viewingFrequency: viewedItems.length
      };
    } catch (error) {
      console.error('Error analyzing viewing patterns:', error);
      return {
        preferredCategories: [],
        preferredPriceRange: { min: 0, max: 0, avg: 0 },
        preferredLocations: [],
        viewingFrequency: 0
      };
    }
  }

  /**
   * Analyze search patterns from AI interactions
   * @param userId The user ID to analyze
   * @param aiInteractions User's AI interactions
   * @returns Search pattern analysis
   */
  private async analyzeSearchPatterns(userId: string, aiInteractions: any[]) {
    try {
      // Filter for search-related interactions
      const searchInteractions = aiInteractions.filter(interaction => {
        const lowerInput = interaction.userInput.toLowerCase();
        return lowerInput.includes('find') || 
               lowerInput.includes('search') || 
               lowerInput.includes('looking for') ||
               lowerInput.includes('want') ||
               lowerInput.includes('need');
      });
      
      // Extract search terms and entities
      const searchTerms: Record<string, number> = {};
      const searchCategories: Record<string, number> = {};
      const searchLocations: Record<string, number> = {};
      const priceReferences: number[] = [];
      
      searchInteractions.forEach(interaction => {
        // Extract entities from search queries
        const entities = this.extractEntities(interaction.userInput);
        
        // Count search terms
        if (entities?.items) {
          entities.items.forEach(item => {
            searchTerms[item] = (searchTerms[item] || 0) + 1;
          });
        }
        
        // Count categories
        if (entities?.items) {
          entities.items.forEach(item => {
            searchCategories[item] = (searchCategories[item] || 0) + 1;
          });
        }
        
        // Count locations
        if (entities?.locations) {
          entities.locations.forEach(location => {
            searchLocations[location] = (searchLocations[location] || 0) + 1;
          });
        }
        
        // Extract price references
        if (entities?.prices) {
          priceReferences.push(...entities.prices);
        }
      });
      
      // Sort search terms by frequency
      const sortedSearchTerms = Object.entries(searchTerms)
        .sort(([,a], [,b]) => b - a)
        .map(([term]) => term);
      
      // Sort categories by frequency
      const sortedCategories = Object.entries(searchCategories)
        .sort(([,a], [,b]) => b - a)
        .map(([category]) => category);
      
      // Sort locations by frequency
      const sortedLocations = Object.entries(searchLocations)
        .sort(([,a], [,b]) => b - a)
        .map(([location]) => location);
      
      // Calculate price statistics
      const minPrice = priceReferences.length > 0 ? Math.min(...priceReferences) : 0;
      const maxPrice = priceReferences.length > 0 ? Math.max(...priceReferences) : 0;
      const avgPrice = priceReferences.length > 0 ? priceReferences.reduce((sum, price) => sum + price, 0) / priceReferences.length : 0;
      
      return {
        frequentSearchTerms: sortedSearchTerms,
        searchedCategories: sortedCategories,
        searchedLocations: sortedLocations,
        pricePreferences: { min: minPrice, max: maxPrice, avg: avgPrice },
        searchFrequency: searchInteractions.length
      };
    } catch (error) {
      console.error('Error analyzing search patterns:', error);
      return {
        frequentSearchTerms: [],
        searchedCategories: [],
        searchedLocations: [],
        pricePreferences: { min: 0, max: 0, avg: 0 },
        searchFrequency: 0
      };
    }
  }

  /**
   * Analyze booking patterns to infer preferences
   * @param userId The user ID to analyze
   * @param userActivity User's activity data
   * @returns Booking pattern analysis
   */
  private async analyzeBookingPatterns(userId: string, userActivity: any) {
    try {
      const bookings = userActivity.recentBookings;
      
      if (!bookings || bookings.length === 0) {
        return {
          bookingFrequency: 0,
          preferredBookingDays: [],
          preferredBookingHours: [],
          avgBookingDuration: 0,
          categoryPreferences: [],
          pricePreferences: { min: 0, max: 0, avg: 0 }
        };
      }
      
      // Analyze temporal patterns
      const bookingDays: Record<string, number> = {};
      const bookingHours: Record<number, number> = {};
      const durations: number[] = [];
      const categories: Record<string, number> = {};
      const prices: number[] = [];
      
      bookings.forEach((booking: any) => {
        // Day analysis
        const day = booking.createdAt.getDay();
        const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        bookingDays[dayNames[day]] = (bookingDays[dayNames[day]] || 0) + 1;
        
        // Hour analysis
        const hour = booking.createdAt.getHours();
        bookingHours[hour] = (bookingHours[hour] || 0) + 1;
        
        // Duration analysis
        if (booking.startDate && booking.endDate) {
          const duration = Math.ceil((booking.endDate.getTime() - booking.startDate.getTime()) / (1000 * 60 * 60 * 24));
          durations.push(duration);
        }
        
        // Category analysis
        if (booking.listing?.category) {
          categories[booking.listing.category] = (categories[booking.listing.category] || 0) + 1;
        }
        
        // Price analysis
        if (booking.listing?.price) {
          prices.push(booking.listing.price);
        }
      });
      
      // Sort days by frequency
      const sortedDays = Object.entries(bookingDays)
        .sort(([,a], [,b]) => b - a)
        .map(([day]) => day);
      
      // Sort categories by frequency
      const sortedCategories = Object.entries(categories)
        .sort(([,a], [,b]) => b - a)
        .map(([category]) => category);
      
      // Calculate statistics
      const avgDuration = durations.length > 0 ? durations.reduce((sum, duration) => sum + duration, 0) / durations.length : 0;
      const minPrice = prices.length > 0 ? Math.min(...prices) : 0;
      const maxPrice = prices.length > 0 ? Math.max(...prices) : 0;
      const avgPrice = prices.length > 0 ? prices.reduce((sum, price) => sum + price, 0) / prices.length : 0;
      
      return {
        bookingFrequency: bookings.length,
        preferredBookingDays: sortedDays,
        preferredBookingHours: Object.keys(bookingHours).map(Number),
        avgBookingDuration: avgDuration,
        categoryPreferences: sortedCategories,
        pricePreferences: { min: minPrice, max: maxPrice, avg: avgPrice }
      };
    } catch (error) {
      console.error('Error analyzing booking patterns:', error);
      return {
        bookingFrequency: 0,
        preferredBookingDays: [],
        preferredBookingHours: [],
        avgBookingDuration: 0,
        categoryPreferences: [],
        pricePreferences: { min: 0, max: 0, avg: 0 }
      };
    }
  }

  /**
   * Analyze wishlist patterns to infer preferences
   * @param userId The user ID to analyze
   * @param userActivity User's activity data
   * @returns Wishlist pattern analysis
   */
  private async analyzeWishlistPatterns(userId: string, userActivity: any) {
    try {
      const wishlistItems = userActivity.wishlistItems;
      
      if (!wishlistItems || wishlistItems.length === 0) {
        return {
          wishlistSize: 0,
          categoryPreferences: [],
          pricePreferences: { min: 0, max: 0, avg: 0 },
          wishlistFrequency: 0
        };
      }
      
      // Analyze wishlist patterns
      const categories: Record<string, number> = {};
      const prices: number[] = [];
      
      wishlistItems.forEach((item: any) => {
        // Category analysis
        if (item.listing?.category) {
          categories[item.listing.category] = (categories[item.listing.category] || 0) + 1;
        }
        
        // Price analysis
        if (item.listing?.price) {
          prices.push(item.listing.price);
        }
      });
      
      // Sort categories by frequency
      const sortedCategories = Object.entries(categories)
        .sort(([,a], [,b]) => b - a)
        .map(([category]) => category);
      
      // Calculate price statistics
      const minPrice = prices.length > 0 ? Math.min(...prices) : 0;
      const maxPrice = prices.length > 0 ? Math.max(...prices) : 0;
      const avgPrice = prices.length > 0 ? prices.reduce((sum, price) => sum + price, 0) / prices.length : 0;
      
      return {
        wishlistSize: wishlistItems.length,
        categoryPreferences: sortedCategories,
        pricePreferences: { min: minPrice, max: maxPrice, avg: avgPrice },
        wishlistFrequency: wishlistItems.length
      };
    } catch (error) {
      console.error('Error analyzing wishlist patterns:', error);
      return {
        wishlistSize: 0,
        categoryPreferences: [],
        pricePreferences: { min: 0, max: 0, avg: 0 },
        wishlistFrequency: 0
      };
    }
  }

  /**
   * Analyze messaging patterns to infer communication preferences
   * @param userId The user ID to analyze
   * @returns Messaging pattern analysis
   */
  private async analyzeMessagingPatterns(userId: string) {
    try {
      // Get user's recent messages
      const messages = await prisma.message.findMany({
        where: {
          OR: [
            { senderId: userId },
            { receiverId: userId }
          ]
        },
        orderBy: { createdAt: 'desc' },
        take: 100
      });
      
      if (messages.length === 0) {
        return {
          messagingFrequency: 0,
          responseTime: 0,
          messageLength: 0,
          communicationPreferences: []
        };
      }
      
      // Analyze messaging patterns
      const responseTimes: number[] = [];
      const messageLengths: number[] = [];
      
      // Calculate response times (simplified - would need more complex logic in real implementation)
      for (let i = 1; i < messages.length; i++) {
        const timeDiff = messages[i-1].createdAt.getTime() - messages[i].createdAt.getTime();
        if (timeDiff > 0 && timeDiff < 24 * 60 * 60 * 1000) { // Less than a day
          responseTimes.push(timeDiff);
        }
      }
      
      // Calculate message lengths
      messages.forEach(message => {
        messageLengths.push(message.content.length);
      });
      
      // Calculate statistics
      const avgResponseTime = responseTimes.length > 0 ? responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length : 0;
      const avgMessageLength = messageLengths.length > 0 ? messageLengths.reduce((sum, length) => sum + length, 0) / messageLengths.length : 0;
      
      return {
        messagingFrequency: messages.length,
        responseTime: avgResponseTime,
        messageLength: avgMessageLength,
        communicationPreferences: []
      };
    } catch (error) {
      console.error('Error analyzing messaging patterns:', error);
      return {
        messagingFrequency: 0,
        responseTime: 0,
        messageLength: 0,
        communicationPreferences: []
      };
    }
  }

  /**
   * Combine all implicit feedback signals to infer user preferences
   * @param viewingPatterns Viewing pattern analysis
   * @param searchPatterns Search pattern analysis
   * @param bookingPatterns Booking pattern analysis
   * @param wishlistPatterns Wishlist pattern analysis
   * @param messagingPatterns Messaging pattern analysis
   * @returns Combined inferred preferences
   */
  private combineImplicitFeedback(
    viewingPatterns: any,
    searchPatterns: any,
    bookingPatterns: any,
    wishlistPatterns: any,
    messagingPatterns: any
  ) {
    try {
      // Weight different signals (these weights could be adjusted based on effectiveness)
      const viewingWeight = 0.2;
      const searchWeight = 0.25;
      const bookingWeight = 0.3;
      const wishlistWeight = 0.2;
      const messagingWeight = 0.05;
      
      // Combine categories from all sources
      const allCategories: Record<string, number> = {};
      
      viewingPatterns.preferredCategories.forEach((category: string) => {
        allCategories[category] = (allCategories[category] || 0) + viewingWeight;
      });
      
      searchPatterns.searchedCategories.forEach((category: string) => {
        allCategories[category] = (allCategories[category] || 0) + searchWeight;
      });
      
      bookingPatterns.categoryPreferences.forEach((category: string) => {
        allCategories[category] = (allCategories[category] || 0) + bookingWeight;
      });
      
      wishlistPatterns.categoryPreferences.forEach((category: string) => {
        allCategories[category] = (allCategories[category] || 0) + wishlistWeight;
      });
      
      // Sort categories by combined score
      const sortedCategories = Object.entries(allCategories)
        .sort(([,a], [,b]) => b - a)
        .map(([category]) => category);
      
      // Combine price preferences (weighted average)
      const viewingPriceScore = viewingPatterns.preferredPriceRange.avg * viewingWeight;
      const searchPriceScore = searchPatterns.pricePreferences.avg * searchWeight;
      const bookingPriceScore = bookingPatterns.pricePreferences.avg * bookingWeight;
      const wishlistPriceScore = wishlistPatterns.pricePreferences.avg * wishlistWeight;
      
      const combinedAvgPrice = viewingPriceScore + searchPriceScore + bookingPriceScore + wishlistPriceScore;
      
      // Combine locations
      const allLocations: Record<string, number> = {};
      
      viewingPatterns.preferredLocations.forEach((location: string) => {
        allLocations[location] = (allLocations[location] || 0) + viewingWeight;
      });
      
      searchPatterns.searchedLocations.forEach((location: string) => {
        allLocations[location] = (allLocations[location] || 0) + searchWeight;
      });
      
      // Sort locations by combined score
      const sortedLocations = Object.entries(allLocations)
        .sort(([,a], [,b]) => b - a)
        .map(([location]) => location);
      
      // Determine user engagement level
      const totalActivity = viewingPatterns.viewingFrequency + 
                           searchPatterns.searchFrequency + 
                           bookingPatterns.bookingFrequency + 
                           wishlistPatterns.wishlistFrequency + 
                           messagingPatterns.messagingFrequency;
      
      let engagementLevel = 'low';
      if (totalActivity > 50) {
        engagementLevel = 'high';
      } else if (totalActivity > 20) {
        engagementLevel = 'medium';
      }
      
      return {
        preferredCategories: sortedCategories.slice(0, 10), // Top 10 categories
        preferredPriceRange: {
          min: combinedAvgPrice * 0.7, // Estimated lower bound
          max: combinedAvgPrice * 1.3, // Estimated upper bound
          avg: combinedAvgPrice
        },
        preferredLocations: sortedLocations.slice(0, 5), // Top 5 locations
        engagementLevel,
        communicationPreferences: messagingPatterns.communicationPreferences,
        bookingPatterns: {
          preferredDays: bookingPatterns.preferredBookingDays.slice(0, 3),
          preferredHours: bookingPatterns.preferredBookingHours.slice(0, 3),
          avgDuration: bookingPatterns.avgBookingDuration
        }
      };
    } catch (error) {
      console.error('Error combining implicit feedback:', error);
      return {
        preferredCategories: [],
        preferredPriceRange: { min: 0, max: 0, avg: 0 },
        preferredLocations: [],
        engagementLevel: 'low',
        communicationPreferences: [],
        bookingPatterns: {
          preferredDays: [],
          preferredHours: [],
          avgDuration: 0
        }
      };
    }
  }

  /**
   * Update user preferences in database based on implicit feedback analysis
   * @param userId The user ID to update
   * @param preferences Inferred preferences
   */
  private async updateUserPreferencesFromImplicitFeedback(userId: string, preferences: any) {
    try {
      // In a real implementation, we would update the user's preference profile in the database
      // For now, we'll just log the update
      console.log(`Updating preferences for user ${userId}:`, preferences);
      
      // This would typically involve:
      // 1. Updating a user_preferences table
      // 2. Updating the user's profile with inferred preferences
      // 3. Using these preferences for future recommendations
      
      // Example of what the database update might look like:
      /*
      await prisma.userPreferences.upsert({
        where: { userId },
        update: {
          preferredCategories: preferences.preferredCategories,
          preferredPriceRangeMin: preferences.preferredPriceRange.min,
          preferredPriceRangeMax: preferences.preferredPriceRange.max,
          preferredLocations: preferences.preferredLocations,
          engagementLevel: preferences.engagementLevel,
          updatedAt: new Date()
        },
        create: {
          userId,
          preferredCategories: preferences.preferredCategories,
          preferredPriceRangeMin: preferences.preferredPriceRange.min,
          preferredPriceRangeMax: preferences.preferredPriceRange.max,
          preferredLocations: preferences.preferredLocations,
          engagementLevel: preferences.engagementLevel,
          createdAt: new Date(),
          updatedAt: new Date()
        }
      });
      */
    } catch (error) {
      console.error('Error updating user preferences from implicit feedback:', error);
    }
  }

  /**
   * Get inferred user preferences based on implicit feedback analysis
   * @param userId The user ID to get preferences for
   * @returns Inferred user preferences
   */
  async getInferredUserPreferences(userId: string) {
    try {
      // In a real implementation, this would fetch from a user_preferences table
      // For now, we'll trigger the analysis and return the results
      const preferences = await this.learnPreferencesFromImplicitFeedback(userId);
      return preferences;
    } catch (error) {
      console.error('Error getting inferred user preferences:', error);
      return null;
    }
  }

  /**
   * Get explicit user preferences from database
   * @param userId The user ID to get preferences for
   * @returns User's explicit preferences
   */
  async getExplicitUserPreferences(userId: string) {
    try {
      const userPreferences = await prisma.userPreferences.findUnique({
        where: { userId }
      });

      if (!userPreferences) {
        return null;
      }

      return {
        preferredCategories: userPreferences.preferredCategories ? JSON.parse(userPreferences.preferredCategories) : [],
        preferredPriceRange: {
          min: userPreferences.preferredPriceRangeMin || 0,
          max: userPreferences.preferredPriceRangeMax || 0
        },
        preferredLocations: userPreferences.preferredLocations ? JSON.parse(userPreferences.preferredLocations) : [],
        engagementLevel: userPreferences.engagementLevel || 'low',
        preferredBookingDays: userPreferences.preferredBookingDays ? JSON.parse(userPreferences.preferredBookingDays) : [],
        preferredBookingHours: userPreferences.preferredBookingHours ? JSON.parse(userPreferences.preferredBookingHours) : []
      };
    } catch (error) {
      console.error('Error getting explicit user preferences:', error);
      return null;
    }
  }

  /**
   * Update explicit user preferences in database
   * @param userId The user ID to update preferences for
   * @param preferences The preferences to update
   * @returns Updated preferences
   */
  async updateExplicitUserPreferences(userId: string, preferences: {
    preferredCategories?: string[];
    preferredPriceRange?: { min: number; max: number };
    preferredLocations?: string[];
    engagementLevel?: string;
  }) {
    try {
      const updatedPreferences = await prisma.userPreferences.upsert({
        where: { userId },
        update: {
          preferredCategories: preferences.preferredCategories ? JSON.stringify(preferences.preferredCategories) : undefined,
          preferredPriceRangeMin: preferences.preferredPriceRange?.min,
          preferredPriceRangeMax: preferences.preferredPriceRange?.max,
          preferredLocations: preferences.preferredLocations ? JSON.stringify(preferences.preferredLocations) : undefined,
          engagementLevel: preferences.engagementLevel,
          updatedAt: new Date()
        },
        create: {
          userId,
          preferredCategories: preferences.preferredCategories ? JSON.stringify(preferences.preferredCategories) : undefined,
          preferredPriceRangeMin: preferences.preferredPriceRange?.min,
          preferredPriceRangeMax: preferences.preferredPriceRange?.max,
          preferredLocations: preferences.preferredLocations ? JSON.stringify(preferences.preferredLocations) : undefined,
          engagementLevel: preferences.engagementLevel,
          createdAt: new Date(),
          updatedAt: new Date()
        }
      });

      return {
        preferredCategories: updatedPreferences.preferredCategories ? JSON.parse(updatedPreferences.preferredCategories) : [],
        preferredPriceRange: {
          min: updatedPreferences.preferredPriceRangeMin || 0,
          max: updatedPreferences.preferredPriceRangeMax || 0
        },
        preferredLocations: updatedPreferences.preferredLocations ? JSON.parse(updatedPreferences.preferredLocations) : [],
        engagementLevel: updatedPreferences.engagementLevel || 'low'
      };
    } catch (error) {
      console.error('Error updating explicit user preferences:', error);
      throw error;
    }
  }

  /**
   * Get combined user preferences (explicit + implicit)
   * Explicit preferences take precedence over implicit ones
   * @param userId The user ID to get preferences for
   * @returns Combined user preferences
   */
  async getUserPreferences(userId: string) {
    try {
      // Get explicit preferences
      const explicitPreferences = await this.getExplicitUserPreferences(userId);
      
      // Get inferred preferences
      const inferredPreferences = await this.getInferredUserPreferences(userId);
      
      // Combine preferences, with explicit taking precedence
      const combinedPreferences = {
        preferredCategories: explicitPreferences?.preferredCategories?.length ? 
          explicitPreferences.preferredCategories : 
          inferredPreferences?.preferredCategories || [],
        preferredPriceRange: explicitPreferences?.preferredPriceRange?.min || explicitPreferences?.preferredPriceRange?.max ?
          explicitPreferences.preferredPriceRange : 
          inferredPreferences?.preferredPriceRange || { min: 0, max: 0 },
        preferredLocations: explicitPreferences?.preferredLocations?.length ? 
          explicitPreferences.preferredLocations : 
          inferredPreferences?.preferredLocations || [],
        engagementLevel: explicitPreferences?.engagementLevel || 
          inferredPreferences?.engagementLevel || 'low',
        preferredBookingDays: explicitPreferences?.preferredBookingDays?.length ? 
          explicitPreferences.preferredBookingDays : 
          inferredPreferences?.preferredBookingDays || [],
        preferredBookingHours: explicitPreferences?.preferredBookingHours?.length ? 
          explicitPreferences.preferredBookingHours : 
          inferredPreferences?.preferredBookingHours || []
      };
      
      return combinedPreferences;
    } catch (error) {
      console.error('Error getting combined user preferences:', error);
      return {
        preferredCategories: [],
        preferredPriceRange: { min: 0, max: 0 },
        preferredLocations: [],
        engagementLevel: 'low',
        preferredBookingDays: [],
        preferredBookingHours: []
      };
    }
  }
}

// Export singleton instance
export const renAIService = new RenAIService();